<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>1&nbsp; Introduction to Statistical Learning – Statistical Learning in R for Social Sciences</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./linear_regression.html" rel="next">
<link href="./index.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-ed96de9b727972fe78a7b5d16c58bf87.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-86b712c1a9842e5c5be4cb0afbdd663e.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>

      .quarto-title-block .quarto-title-banner h1,
      .quarto-title-block .quarto-title-banner h2,
      .quarto-title-block .quarto-title-banner h3,
      .quarto-title-block .quarto-title-banner h4,
      .quarto-title-block .quarto-title-banner h5,
      .quarto-title-block .quarto-title-banner h6
      {
        color: white;
      }

      .quarto-title-block .quarto-title-banner {
        color: white;
background: #00868B;
      }
</style>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./introduction_to_statistical_learning.html"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction to Statistical Learning</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <div class="quarto-title-block"><div><h1 class="title"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction to Statistical Learning</span></h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Statistical Learning in R for Social Sciences</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./introduction_to_statistical_learning.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction to Statistical Learning</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./linear_regression.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Linear Regression</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#statistical-learning-formula" id="toc-statistical-learning-formula" class="nav-link active" data-scroll-target="#statistical-learning-formula"><span class="header-section-number">1.1</span> Statistical Learning Formula</a></li>
  <li><a href="#relationship-between-dependent-and-independent-variable" id="toc-relationship-between-dependent-and-independent-variable" class="nav-link" data-scroll-target="#relationship-between-dependent-and-independent-variable"><span class="header-section-number">1.2</span> Relationship between Dependent and Independent Variable</a>
  <ul class="collapse">
  <li><a href="#parametric-vs-non-parametric-methods" id="toc-parametric-vs-non-parametric-methods" class="nav-link" data-scroll-target="#parametric-vs-non-parametric-methods"><span class="header-section-number">1.2.1</span> Parametric vs non-parametric methods</a></li>
  <li><a href="#supervised-vs-unsupervised-learning" id="toc-supervised-vs-unsupervised-learning" class="nav-link" data-scroll-target="#supervised-vs-unsupervised-learning"><span class="header-section-number">1.2.2</span> Supervised vs unsupervised learning</a></li>
  </ul></li>
  <li><a href="#assessing-model-accuracy" id="toc-assessing-model-accuracy" class="nav-link" data-scroll-target="#assessing-model-accuracy"><span class="header-section-number">1.3</span> Assessing Model Accuracy</a>
  <ul class="collapse">
  <li><a href="#the-regression-setting" id="toc-the-regression-setting" class="nav-link" data-scroll-target="#the-regression-setting"><span class="header-section-number">1.3.1</span> The regression setting</a></li>
  <li><a href="#the-classification-setting" id="toc-the-classification-setting" class="nav-link" data-scroll-target="#the-classification-setting"><span class="header-section-number">1.3.2</span> The Classification Setting</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p><strong>Statistical learning</strong> refers to a broad set of approaches and techniques for estimating the function that connects independent variables to an dependent variable. At its core, statistical learning is concerned with understanding the relationship between variables and using that understanding either to make predictions about future observations or to gain insight into how different factors influence an outcome.</p>
<section id="statistical-learning-formula" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="statistical-learning-formula"><span class="header-section-number">1.1</span> Statistical Learning Formula</h2>
<p>The fundamental idea of statistical learning can be expressed through a simple formula:</p>
<p><span class="math inline">\(Y = f(X) + \epsilon\)</span></p>
<p>This formula tells us that any outcome we wish to study or predict can be understood as the result of some systematic relationship between independent and dependent variables, plus some random variation that we cannot fully explain or control. The goal of statistical learning is to estimate the function <span class="math inline">\(f\)</span> based on observed data, so that we can either predict Y for new observations or understand how changes in X are associated with changes in Y.</p>
<p>Let’s now explain each component of this formula in detail.</p>
<ul>
<li><p>The <strong>dependent variable</strong> or response, denoted by <strong>Y</strong>, represents the response that we are trying to understand, explain, or predict. This is the variable whose variation we want to account for using other available information. It is called <em>dependent</em> precisely because its values depend on, or are influenced by, other variables in the system we are studying.</p></li>
<li><p>The <strong>independent variable</strong> or predictor, denoted by <strong>X</strong>, represents the input information that we use to explain or predict the outcome. In most realistic situations, we have multiple predictors rather than just one, so X typically represents a collection of variables written as <span class="math inline">\(X = (X_1, X_2, ..., X_p)\)</span>, where <span class="math inline">\(X_p\)</span> indicates the total number of predictors. The key characteristic of predictors is that they provide information that helps us understand or anticipate the values of the dependent variable.</p></li>
<li><p>The function <strong><span class="math inline">\(f\)</span></strong> represents the <strong>systematic relationship between the dependent variable and the indipendent variable</strong>. This function captures all the information that the independent variables collectively provide about the dependent variable. In other words, <span class="math inline">\(f\)</span> describes the pattern or rule that connects predictors to response in a consistent, reproducible way. The crucial point is that in real-world applications, the true form of <span class="math inline">\(f\)</span> is almost always unknown to us. We never directly observe this function; instead, we must estimate it based on the data we have collected. The entire enterprise of statistical learning revolves around developing methods to estimate <span class="math inline">\(f\)</span> as accurately as possible.</p></li>
<li><p>The <strong>error term</strong>, denoted by <strong><span class="math inline">\(\epsilon\)</span></strong>, represents the random component of the relationship between dependent and independent variables. This term captures all the variation in Y that cannot be explained by the <span class="math inline">\(X_p\)</span>. The error term is assumed to be independent of X and to have a mean of zero, which means that on average, the errors cancel out and do not systematically bias our predictions in one direction or another. The error term exists for several important reasons.</p>
<ul>
<li><p>First, there may be variables that influence dependent variable but that we have not measured or included in our analysis.</p></li>
<li><p>Second, even if we could measure every relevant variable, there might be inherent randomness or unpredictability in the phenomenon we are studying.</p></li>
<li><p>Third, our measurements themselves may contain some degree of imprecision or noise.</p></li>
</ul></li>
</ul>
<p>To make these concepts concrete, let me illustrate them with the example. Consider a researcher studying income inequality and social mobility. The researcher might want to understand what determines a person’s income in adulthood. The dependent variable Y would be adult income, measured in monetary units. The predictors X might encompass the person’s own educational credentials, their occupation, the region where they live, their parents’ socioeconomic status, their race and gender, and the number of years of work experience they have accumulated. The function <span class="math inline">\(f\)</span> would capture the systematic relationships between these characteristics and income, revealing how the labor market rewards different attributes and how social background continues to influence economic outcomes across generations. The error term <span class="math inline">\(\epsilon\)</span> would account for all the variation in income that these measured factors cannot explain. This residual variation might stem from unmeasured differences in job performance, luck in finding particularly good or bad employment matches, health shocks that affect earning capacity, or discrimination that varies in ways not captured by the measured variables.</p>
<p>We can write this relationship as: <span class="math inline">\(Y\ =\ f(X_1,\ X_2,\ X_3,\ X_4,\ X_5,\ X_6,\ X_7)\ +\ ϵ\)</span></p>
<p>In this formula, Y represents adult income measured in monetary units such as annual earnings in euros. This is the response we are trying to understand or predict. The predictors are defined as follows.</p>
<ul>
<li><p><span class="math inline">\(X_1\)</span> represents the person’s educational credentials, which might be measured as years of schooling completed or as the highest degree obtained.</p></li>
<li><p><span class="math inline">\(X_2\)</span> represents occupation, which could be coded as occupational prestige scores or as categorical indicators for different types of jobs.</p></li>
<li><p><span class="math inline">\(X_3\)</span> represents the geographic region where the person lives and works, capturing spatial variation in labor markets and cost of living.</p></li>
<li><p><span class="math inline">\(X_4\)</span> represents parents’ socioeconomic status, which might be measured through parental income, parental education, or a composite index combining multiple indicators of family background.</p></li>
<li><p><span class="math inline">\(X_5\)</span> represents race, coded as categorical indicators for different racial or ethnic groups.</p></li>
<li><p><span class="math inline">\(X_6\)</span> represents gender, typically coded as a binary or categorical variable.</p></li>
<li><p><span class="math inline">\(X_7\)</span> represents years of work experience, measuring how long the person has been participating in the labor force.</p></li>
</ul>
<p>The function <span class="math inline">\(f\)</span> captures the systematic relationship between all these predictors and adult income. This function describes how the labor market values different combinations of education, occupation, location, background, and demographic characteristics. The precise form of <span class="math inline">\(f\)</span> is unknown to us and must be estimated from data. It might be relatively simple, such as a linear combination of the predictors, or it might be quite complex, involving interactions between variables and nonlinear relationships.</p>
<p>The error term <span class="math inline">\(\epsilon\)</span> represents all the variation in adult income that cannot be explained by the seven predictors we have included. This encompasses unmeasured factors such as individual differences in productivity, motivation, and interpersonal skills, as well as random events like fortunate or unfortunate timing in job searches, health events that affect earning capacity, and idiosyncratic experiences of discrimination or favoritism in the workplace, and so on.</p>
</section>
<section id="relationship-between-dependent-and-independent-variable" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="relationship-between-dependent-and-independent-variable"><span class="header-section-number">1.2</span> Relationship between Dependent and Independent Variable</h2>
<p>The function <span class="math inline">\(f\)</span> is the central object of interest in statistical learning. It represents the systematic relationship between the independent variable and the dependent variable, capturing all the information that the independent variables provide about the dependent variable. When we say that <span class="math inline">\(Y = f(X) + \epsilon\)</span>, we are asserting that the response can be decomposed into two parts: a predictable component <span class="math inline">\(f(X)\)</span> that depends on the values of the predictors, and an unpredictable component <span class="math inline">\(\epsilon\)</span> that represents random variation. The function <span class="math inline">\(f\)</span> is what connects the world of responses to the world of predictors in a consistent, reproducible manner.</p>
<p>Understanding the nature of <span class="math inline">\(f\)</span> is crucial because it embodies the underlying pattern that governs how changes in the independent variable translate into changes in the dependent variable. If we knew <span class="math inline">\(f\)</span> perfectly, we would understand exactly how each predictor influences the response, how predictors interact with one another, and what response to expect for any given combination of predictor values. However, in virtually all real-world applications, <span class="math inline">\(f\)</span> is unknown. We never observe <span class="math inline">\(f\)</span> directly; we only observe data points consisting of predictor values and corresponding responses. The entire purpose of statistical learning is to use these observed data points to construct an estimate of <span class="math inline">\(f\)</span>, which we denote as <span class="math inline">\(\hat{f}\)</span>. The reasons we might want to estimate <span class="math inline">\(f\)</span> fall into two broad categories: prediction and inference. These two goals are conceptually distinct, and they often lead us to prefer different types of statistical learning methods.</p>
<p><strong>Prediction</strong> is concerned with accurately anticipating the value of Y for new observations where we know the predictors X but do not yet know the response of the predictors. In prediction tasks, we treat <span class="math inline">\(\hat{f}\)</span> as a kind of black box. We do not necessarily care about the internal workings of our estimated function or about which specific predictors matter most. What we care about is whether our estimate <span class="math inline">\(\hat{f}\)</span> produces accurate predictions when applied to new data. The quality of predictions depends on two sources of error:</p>
<ol type="1">
<li><p>The first is <strong>reducible error</strong>, which arises because our estimate <span class="math inline">\(\hat{f}\)</span> is imperfect and does not exactly match the true <span class="math inline">\(f\)</span>. We can potentially reduce this error by using better statistical learning methods or by collecting more data.</p></li>
<li><p>The second is <strong>irreducible error</strong>, which corresponds to the variance of <span class="math inline">\(\epsilon\)</span>. Even if we had a perfect estimate of <span class="math inline">\(f\)</span>, our predictions would still contain some error because Y is inherently influenced by random factors that cannot be predicted from X alone.</p></li>
</ol>
<p><strong>Inference</strong>, by contrast, is concerned with understanding the relationship between the predictors and the outcome. When our goal is inference, we cannot treat <span class="math inline">\(\hat{f}\)</span> as a black box because we need to know its exact form. We want to answer questions such as which predictors are associated with the response, what is the direction and magnitude of each predictor’s effect, and whether the relationships are linear or more complex. Inference requires that our estimate <span class="math inline">\(\hat{f}\)</span> be interpretable, meaning that we can examine it and draw substantive conclusions about how the world works.</p>
<p>In practice, many research projects involve elements of both prediction and inference. A researcher studying income might want to understand the determinants of earnings while also developing a model that can predict incomes for new individuals. However, there is often tension between these goals because the methods that produce the most accurate predictions are not always the most interpretable, and the most interpretable methods do not always produce the best predictions.</p>
<section id="parametric-vs-non-parametric-methods" class="level3" data-number="1.2.1">
<h3 data-number="1.2.1" class="anchored" data-anchor-id="parametric-vs-non-parametric-methods"><span class="header-section-number">1.2.1</span> Parametric vs non-parametric methods</h3>
<p>Having established why we want to estimate <span class="math inline">\(f\)</span>, let us now turn to the question of how we estimate <span class="math inline">\(f\)</span>. Statistical learning methods for estimating <span class="math inline">\(f\)</span> can be broadly divided into two categories: parametric methods and non-parametric methods. These two approaches differ fundamentally in the assumptions they make about the form of <span class="math inline">\(f\)</span> and in the way they use data to construct an estimate.</p>
<p><strong>Parametric methods</strong> proceed in two steps. In the first step, we make an assumption about the functional form of <span class="math inline">\(f\)</span>. That is, we specify in advance what kind of mathematical relationship we believe connects the predictors to the outcome. The most common assumption is that <span class="math inline">\(f\)</span> is linear, meaning that we assume the relationship can be written as <span class="math inline">\(f(X) = \beta_0 + \beta_1X_1 + \beta_2X_2 + ... + \beta_pX_p\)</span>. This linear model asserts that the response is a weighted sum of the predictors, where the weights <span class="math inline">\(\beta_1, \beta_2, ..., \beta_p\)</span> are unknown coefficients that quantify the contribution of each predictor, and <span class="math inline">\(\beta_0\)</span> is an intercept term representing the expected response when all predictors equal zero. By assuming a linear form, we have dramatically simplified the problem. Instead of having to estimate an arbitrary, potentially very complex function <span class="math inline">\(f\)</span>, we only need to estimate the intercept and the p coefficients. In the second step of the parametric approach, we use the observed data to fit or train the model. This means finding values of the parameters that make the model match the data as closely as possible. For the linear model, the most common fitting procedure is ordinary least squares, which chooses the parameter values that minimize the sum of squared differences between the observed responses and the responses predicted by the model. Once we have estimated the parameters, our estimate <span class="math inline">\(\hat{f}\)</span> is fully specified, and we can use it for prediction or inference.</p>
<p>The parametric approach has several important advantages. Because we have reduced the problem to estimating a fixed number of parameters, parametric methods are computationally efficient and can work well even with relatively small samples. Furthermore, the resulting models are typically easy to interpret. In a linear model, each coefficient tells us how much the expected responses changes when the corresponding predictor increases by one unit, holding all other predictors constant. This interpretability makes parametric models particularly valuable for inference. However, parametric methods also have a significant limitation. The assumption we make about the form of <span class="math inline">\(f\)</span> may be wrong. If the true relationship between the predictors and the response is nonlinear or involves complex interactions, a linear model will fail to capture these features and will provide a poor approximation to <span class="math inline">\(f\)</span>. We can try to address this problem by using more flexible parametric models that include polynomial terms, interaction effects, or other elaborations of the basic linear form. But as we make our parametric model more flexible, we must estimate more parameters, which requires more data and increases the risk of a phenomenon called overfitting. <strong>Overfitting</strong> occurs when a model fits the training data very well but performs poorly on new data because it has captured random noise rather than genuine patterns. The model essentially memorizes the idiosyncrasies of the particular sample rather than learning the underlying relationship.</p>
<p><strong>Non-parametric methods</strong> take a fundamentally different approach. Instead of assuming a specific functional form for <span class="math inline">\(f\)</span>, non-parametric methods seek an estimate that gets close to the data points without imposing strong prior assumptions about the shape of the relationship. The idea is to let the data speak for themselves and to allow <span class="math inline">\(\hat{f}\)</span> to take whatever form best fits the observed patterns. One example of a non-parametric method is the thin-plate spline, which estimates <span class="math inline">\(f\)</span> as a smooth surface that passes near the observed data points. The analyst does not specify in advance that <span class="math inline">\(f\)</span> should be linear or quadratic or any other particular form. Instead, the method finds a smooth function that fits the data well, subject to some constraint on how wiggly or rough the function is allowed to be. Another example is the k-nearest neighbors method, which predicts the outcome for a new observation by averaging the outcomes of the k training observations that are most similar to it in terms of the predictor values.</p>
<p>The main advantage of non-parametric methods is their flexibility. Because they do not assume a particular form for <span class="math inline">\(f\)</span>, they can potentially capture a much wider range of relationships, including highly nonlinear patterns and complex interactions that would be missed by a simple parametric model. If the true <span class="math inline">\(f\)</span> has an unusual or complicated shape, a non-parametric method has a better chance of approximating it accurately. However, non-parametric methods also have important disadvantages. Because they do not reduce the problem to estimating a small number of parameters, they typically require much larger samples to produce accurate estimates. The flexibility that allows non-parametric methods to fit complex patterns also makes them prone to overfitting, especially when sample sizes are limited. Furthermore, the estimates produced by non-parametric methods are often difficult to interpret. A non-parametric prediction does not come with coefficients that tell us how each predictor contributes to the outcome. This lack of interpretability makes non-parametric methods less useful for inference, even when they excel at prediction.</p>
<p>The choice between parametric and non-parametric methods involves a fundamental trade-off. Parametric methods impose structure on the problem, which makes estimation easier and results more interpretable, but at the cost of potentially misspecifying the true form of <span class="math inline">\(f\)</span>. Non-parametric methods avoid this misspecification risk by staying flexible, but they require more data and produce less interpretable results. In practice, the best choice depends on the goals of the analysis, the amount of data available, and how much prior knowledge we have about the likely form of the relationship.</p>
<p>This brings us to a closely related issue: the trade-off between prediction accuracy and model interpretability. In statistical learning, there is often an inverse relationship between how flexible a method is and how interpretable its results are. Methods that impose strong restrictions on the form of <span class="math inline">\(f\)</span> tend to be highly interpretable but may not fit complex patterns very well. Methods that are highly flexible can capture intricate relationships but produce results that are difficult for humans to understand.</p>
<p>At one end of the spectrum, we have highly restrictive methods like linear regression and its close relatives. Linear regression assumes that <span class="math inline">\(f\)</span> is a linear combination of the predictors, which is a very strong restriction. This restriction means that linear regression can only produce straight lines in one dimension, flat planes in two dimensions, and hyperplanes in higher dimensions. The advantage is that the results are extremely interpretable. Each coefficient has a clear meaning: it tells us the expected change in Y associated with a one-unit increase in the corresponding predictor, holding other predictors constant. We can examine the coefficients and immediately understand which predictors matter, how large their effects are, and in which direction they operate. For inference purposes, this interpretability is invaluable.</p>
<p>Moving along the spectrum toward greater flexibility, we encounter methods like generalized additive models, which relax the linearity assumption by allowing each predictor to have a potentially nonlinear effect on the response, while still maintaining an additive structure. These models are more flexible than linear regression and can capture curved relationships, but they remain reasonably interpretable because we can plot and examine the estimated effect of each predictor separately. Further along the spectrum, we find decision trees, which partition the predictor space into regions and assign a predicted response to each region. Trees are moderately flexible and can capture interactions and nonlinearities, but they remain somewhat interpretable because we can visualize the tree structure and see which predictors are used to make splits and at what values. These methods can approximate extremely complex functions and often achieve superior predictive accuracy on difficult problems. However, their results are very hard to interpret.</p>
<p>One might think that we should always prefer the most flexible method available, reasoning that greater flexibility means better ability to capture the true <span class="math inline">\(f\)</span>. Surprisingly, this is not the case. More flexible methods are not always better, even when our sole goal is prediction. The reason is overfitting. A highly flexible method can fit the training data very closely, including the random noise in that particular sample. When we apply the model to new data, the noise patterns will be different, and the overfitted model will perform poorly. In many situations, a simpler, more restrictive model that does not fit the training data as closely will actually generalize better to new observations.</p>
<p>This phenomenon is especially important when sample sizes are limited. With a small sample, there is not enough information to reliably estimate a complex, flexible model, and the risk of overfitting is high. In such cases, imposing structure through a parametric model can actually improve predictive performance by preventing the model from chasing noise. As sample sizes grow larger, we can afford to use more flexible methods because there is enough information to distinguish genuine patterns from random variation.</p>
</section>
<section id="supervised-vs-unsupervised-learning" class="level3" data-number="1.2.2">
<h3 data-number="1.2.2" class="anchored" data-anchor-id="supervised-vs-unsupervised-learning"><span class="header-section-number">1.2.2</span> Supervised vs unsupervised learning</h3>
<p>To complete the overview of the foundational concepts in statistical learning, we need to understand additional distinction between supervised and unsupervised learning that help us categorize different types of learning problems.</p>
<p><strong>Supervised learning</strong> refers to situations where for each observation in our dataset, we have both predictor measurements and a corresponding response measurement. The term <em>supervised</em> reflects the idea that the learning process is guided or supervised by the known dependent variables. We observe what actually happened for each case in our training data, and we use this information to learn the relationship between independent variables and dependent variable. All the methods we have discussed so far fall into the supervised learning category when applied to problems where outcomes are observed. The fundamental goal of supervised learning is to build a model that can predict the response for new observations based on their predictor values, or to understand how the predictors relate to the response. In social sciences research, most studies involve supervised learning because we typically have data on both the explanatory variables and the outcome of interest. For example, when we study the relationship between education and income, we observe both variables for the individuals in our sample, which allows us to estimate how education influences earnings.</p>
<p><strong>Unsupervised learning</strong> describes a fundamentally different situation where we observe predictor measurements for each observation but have no corresponding response variable. Without a dependent variable to predict or explain, we cannot fit a regression model or train a classifier. Instead, unsupervised learning seeks to discover patterns, structures, or groupings within the data itself. The most common unsupervised learning task is cluster analysis, which attempts to identify subgroups of observations that are similar to one another. For instance, a researcher might have survey data containing many variables about people’s attitudes, behaviors, and demographic characteristics, but no predefined categorization of people into types. Cluster analysis could reveal that the respondents naturally fall into distinct groups based on their patterns of responses, perhaps identifying clusters that correspond to different lifestyles, political orientations, or consumption patterns. The key feature of unsupervised learning is that there is no correct answer to supervise the learning process. We are not trying to predict a known outcome but rather to uncover hidden structure in the data. This makes unsupervised learning more exploratory and somewhat more subjective than supervised learning, since there is no objective criterion like prediction accuracy to evaluate whether we have found the right structure.</p>
<table class="caption-top table">
<caption><strong>Table 1.1</strong> Summary table of statistical learning methods</caption>
<colgroup>
<col style="width: 15%">
<col style="width: 23%">
<col style="width: 21%">
<col style="width: 20%">
<col style="width: 19%">
</colgroup>
<thead>
<tr class="header">
<th>Method</th>
<th>Unsupervised / Supervised</th>
<th>Parametric / Non-parametric</th>
<th>Flexibility</th>
<th>Interpretability</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Linear Regression</td>
<td>Supervised</td>
<td>Parametric</td>
<td>Low</td>
<td>High</td>
</tr>
<tr class="even">
<td>Ridge Regression</td>
<td>Supervised</td>
<td>Parametric</td>
<td>Low</td>
<td>High</td>
</tr>
<tr class="odd">
<td>Lasso</td>
<td>Supervised</td>
<td>Parametric</td>
<td>Low</td>
<td>High</td>
</tr>
<tr class="even">
<td>Logistic Regression</td>
<td>Supervised</td>
<td>Parametric</td>
<td>Low</td>
<td>High</td>
</tr>
<tr class="odd">
<td>Generalized Additive Models</td>
<td>Supervised</td>
<td>Parametric (additive structure)</td>
<td>Medium</td>
<td>Medium-High</td>
</tr>
<tr class="even">
<td>Decision Trees</td>
<td>Supervised</td>
<td>Non-parametric</td>
<td>Medium</td>
<td>Medium</td>
</tr>
<tr class="odd">
<td>Bagging</td>
<td>Supervised</td>
<td>Non-parametric</td>
<td>High</td>
<td>Low</td>
</tr>
<tr class="even">
<td>Random Forests</td>
<td>Supervised</td>
<td>Non-parametric</td>
<td>High</td>
<td>Low</td>
</tr>
<tr class="odd">
<td>Boosting</td>
<td>Supervised</td>
<td>Non-parametric</td>
<td>High</td>
<td>Low</td>
</tr>
<tr class="even">
<td>Linear Support Vector Machines</td>
<td>Supervised</td>
<td>Parametric</td>
<td>Low-Medium</td>
<td>Medium</td>
</tr>
<tr class="odd">
<td>Nonlinear Support Vector Machines</td>
<td>Supervised</td>
<td>Non-parametric</td>
<td>High</td>
<td>Low</td>
</tr>
<tr class="even">
<td>K-Nearest Neighbors</td>
<td>Supervised</td>
<td>Non-parametric</td>
<td>High</td>
<td>Low</td>
</tr>
<tr class="odd">
<td>Neural Networks</td>
<td>Supervised</td>
<td>Non-parametric</td>
<td>Very High</td>
<td>Very Low</td>
</tr>
<tr class="even">
<td>Deep Learning</td>
<td>Supervised</td>
<td>Non-parametric</td>
<td>Very High</td>
<td>Very Low</td>
</tr>
<tr class="odd">
<td>K-Means Clustering</td>
<td>Unsupervised</td>
<td>Non-parametric</td>
<td>Medium</td>
<td>Medium</td>
</tr>
<tr class="even">
<td>Hierarchical Clustering</td>
<td>Unsupervised</td>
<td>Non-parametric</td>
<td>Medium</td>
<td>Medium-High</td>
</tr>
<tr class="odd">
<td>Principal Component Analysis</td>
<td>Unsupervised</td>
<td>Parametric</td>
<td>Low</td>
<td>Medium-High</td>
</tr>
<tr class="even">
<td>Factor Analysis</td>
<td>Unsupervised</td>
<td>Parametric</td>
<td>Low</td>
<td>High</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="assessing-model-accuracy" class="level2" data-number="1.3">
<h2 data-number="1.3" class="anchored" data-anchor-id="assessing-model-accuracy"><span class="header-section-number">1.3</span> Assessing Model Accuracy</h2>
<p>A fundamental question in statistical learning can be expressed as a: <em>how do we know which method or model is the best one to use for a given dataset?</em> This might seem like a simple question at first, but it is actually one of the most challenging aspects of statistical learning in practice.</p>
<p>When we build a statistical learning model, we need a way to evaluate how well it actually works. In other words, we need to measure how close the model’s predictions are to the real values we observe in the data. This is what we mean by <strong>measuring the quality of fit</strong>. Without such a measure, we would have no principled way of comparing different models or deciding whether a particular approach is adequate for our research question.</p>
<section id="the-regression-setting" class="level3" data-number="1.3.1">
<h3 data-number="1.3.1" class="anchored" data-anchor-id="the-regression-setting"><span class="header-section-number">1.3.1</span> The regression setting</h3>
<p>In the regression setting, where the response variable is quantitative, the most commonly used measure of fit is the <strong>mean squared error</strong> (MSE). The mean squared error is calculated by taking each observation in the dataset, computing the difference between the actual observed value and the value that the model predicts, squaring that difference, and then averaging all of these squared differences across every observation. Formally, MSE is expressed as:</p>
<p><span class="math inline">\(MSE = \frac{1}{n} \times \sum_{i=1}^n(y_i - \hat{f}(x_i))^2\)</span></p>
<p>The logic behind this measure is straightforward. If our model’s predictions are very close to the true observed values, the differences will be small, the squared differences will be even smaller, and the average of all those squared differences will be a small number. On the other hand, if the model produces predictions that are far from the actual values for at least some observations, the squared differences will be large, pulling the MSE upward. Squaring the differences serves two purposes: it ensures that positive and negative errors do not cancel each other out, and it penalizes larger errors more heavily than smaller ones.</p>
<p>To make this concrete, consider our example of predicting adult income. Suppose the researcher has collected data on a sample of one thousand individuals, recording each person’s educational credentials, occupation, region, parents’ socioeconomic status, race, gender, and years of work experience, along with their actual adult income. The researcher then estimates the function <span class="math inline">\(f\)</span> using some statistical learning method - perhaps a linear regression model - to produce a predicted income <span class="math inline">\(\hat{f}(x_i)\)</span> for each person in the dataset. For one individual, the model might predict an annual income of 38,000 euros while the person actually earns 42,000 euros, yielding a difference of 4,000 euros. For another individual, the model might predict 55,000 euros while the person earns 53,000 euros, giving a difference of 2,000 euros. The mean squared error takes all of these individual discrepancies, squares each one, and averages them across the entire sample. The resulting number gives us a single summary of how well the model’s predictions match reality.</p>
<p>The MSE we just described is computed using the same data that were used to build the model. This is called the <strong>training MSE</strong>, because it measures how well the model fits the training data - the observations the model has already seen and learned from. At first glance, it might seem perfectly reasonable to use the training MSE to evaluate a model. After all, if a model fits the data well, that should mean it is a good model. However, this reasoning is flawed. In most practical situations, we do not actually care how well the model fits the data it was trained on. What we really care about is how well the model will perform on new data that it has never seen before. This new, unseen data is called test data, and the MSE computed on test data is called the <strong>test MSE</strong>.</p>
<p>To understand why this distinction matters so profoundly, let us return to our income inequality example. Suppose the researcher has built a model using data from a survey conducted in 2018, which includes information on one thousand individuals and their incomes. The model fits these one thousand observations well, producing a low training MSE. But the real purpose of the model is not to predict the incomes of these specific one thousand people whose incomes the researcher already knows. The real purpose is to predict incomes for new individuals - perhaps people surveyed in 2020, or individuals from a different but comparable population - based on their educational credentials, occupation, region, family background, race, gender, and work experience. The question that truly matters is whether the model will produce accurate predictions for these new cases, not whether it accurately reproduces the incomes of the people it was trained on.</p>
<p>This is the fundamental insight: the training MSE measures something that is not of primary interest, while the test MSE measures something that is. A model that performs beautifully on its training data might perform poorly on new data, and a model with a somewhat higher training MSE might actually generalize better to unseen observations.</p>
<p>Many statistical learning methods are designed, either directly or indirectly, to minimize the training MSE. They adjust their estimates and coefficients specifically to fit the training observations as closely as possible. As a result, the training MSE can be driven very low - sometimes all the way to zero - but this does not mean that the model has learned the true underlying patterns in the data. Instead, the model may have started to learn the noise in the training data, the random fluctuations and idiosyncratic features that are specific to that particular sample and will not appear again in new data. In our income example, imagine that the researcher uses a highly flexible model that can adapt to very fine details in the data. This model might learn that in the specific 2018 sample, there was one individual from a particular small region who had low education but unusually high income, perhaps due to an inheritance or a lucky business venture. A very flexible model might adjust its predictions to accommodate this particular case, effectively learning the specific circumstances of this one person rather than the general relationship between education and income. When the model is then applied to new individuals, this kind of overly specific learning will not help and may actually hurt prediction accuracy, because the idiosyncratic patterns of the training data do not generalize to the broader population.</p>
<p>The chapter illustrates this problem using the concept of model flexibility. A model’s flexibility refers to how closely it can conform to the patterns in the training data. At one end of the spectrum, a simple linear regression is relatively inflexible - it fits a straight line (or a flat hyperplane in multiple dimensions) through the data. At the other end, highly flexible methods like smoothing splines or very complex nonlinear models can bend and curve to follow almost every individual data point. The key finding, which the chapter demonstrates through several examples, is that as model flexibility increases, the training MSE will always decrease - because a more flexible model can always conform more closely to the training data. However, the test MSE does not simply decrease along with the training MSE. Instead, the test MSE initially decreases as the model becomes flexible enough to capture the real underlying patterns, but at some point it reaches a minimum and then begins to increase again. This produces the characteristic U-shaped curve that appears throughout the book.</p>
<p>In the income inequality context, a linear regression model assumes that the relationship between each predictor and income is a straight line. This might miss important nonlinearities - for example, the return to education might increase sharply once a person obtains a university degree, rather than rising smoothly with each additional year of schooling. A somewhat more flexible model could capture this nonlinearity and would likely produce better predictions on new data, yielding a lower test MSE. However, if the researcher keeps increasing flexibility - allowing the model to capture finer and finer details of the training data - at some point the model starts picking up noise rather than signal. It might learn that in this particular sample, people with exactly fourteen years of education and exactly eight years of work experience who live in one specific region have unusually high incomes, when in reality this pattern is just a coincidence in the sample. At this point, the test MSE starts rising again, even as the training MSE continues to fall.</p>
<p>The phenomenon, where a model fits the training data too closely and as a result performs poorly on new data, is called <strong>overfitting</strong>. It occurs when a statistical learning method works too hard to find patterns in the training data and ends up capturing patterns that are caused by random chance rather than by genuine features of the underlying relationship. When overfitting occurs, the training MSE is very low but the test MSE is high, because the spurious patterns the model learned from the training data do not exist in the test data.</p>
<p>To understand overfitting in our example, think of it this way. The true relationship between the seven predictors and adult income has a certain level of complexity. Education, occupation, region, family background, race, gender, and work experience all influence income in systematic ways, but those systematic influences operate at a general level - they describe broad patterns that hold across many individuals. A good model captures these broad, stable patterns. An overfit model goes beyond these patterns and starts memorizing the specific incomes of specific individuals in the training sample, including all the random variation that makes each person’s income slightly different from what the general pattern would predict. Since this random variation is specific to the training sample and will not replicate in new data, the overfit model ends up making worse predictions when applied to new observations.</p>
<p>Regardless of whether overfitting has occurred, the training MSE will almost always be smaller than the test MSE. This is simply because most methods are designed to minimize the training MSE, so they will naturally fit the training data better than any data they have not seen. Overfitting refers specifically to the situation where additional flexibility leads to a worse test MSE - that is, where a less flexible model would actually have produced better predictions on new data.</p>
<p>In practice, the researcher can usually compute the training MSE quite easily, since it only requires the data used to fit the model. However, estimating the test MSE is considerably more difficult because test data may not be available. If the researcher studying income inequality has only one dataset, there is no separate pool of unseen observations on which to evaluate the model. One important solution to this problem is <strong>cross-validation</strong> which provides a way to estimate the test MSE using only the training data by cleverly splitting the data into parts and alternating which part serves as the training set and which serves as the test set. This allows the researcher to approximate how well the model would perform on genuinely new data without actually needing a separate test dataset.</p>
<p>Summarizing the above, evaluating a model’s quality requires looking beyond how well it fits the data it was trained on. The true measure of a model’s value is its ability to make accurate predictions for observations it has never encountered. This principle applies whether we are predicting any phenomenon in the social sciences. Understanding the distinction between training performance and test performance, and recognizing the danger of overfitting, are essential foundations for the study of statistical learning.</p>
<section id="the-bias-variance-trade-off" class="level4" data-number="1.3.1.1">
<h4 data-number="1.3.1.1" class="anchored" data-anchor-id="the-bias-variance-trade-off"><span class="header-section-number">1.3.1.1</span> The Bias-Variance Trade-Off</h4>
<p>In the previous section, we established that when we evaluate a statistical learning model, what truly matters is the test MSE - how well the model predicts outcomes for new, previously unseen observations. We also observed that as model flexibility increases, the test MSE tends to follow a characteristic U-shape: it initially decreases, reaches a minimum at some optimal level of flexibility, and then begins to increase again. The bias-variance trade-off is the theoretical explanation for why this U-shape occurs. It is one of the most important concepts in all of statistical learning, and understanding it deeply will help us make better decisions about which models to use and how flexible those models should be.</p>
<p>Expected test MSE at any given point can always be broken down into the sum of three distinct quantities:</p>
<ol type="1">
<li><p>the variance of the model’s prediction,</p></li>
<li><p>the squared bias of the model’s prediction, and</p></li>
<li><p>the variance of the irreducible error.</p></li>
</ol>
<p>This decomposition is expressed formally as:</p>
<p><span class="math display">\[
E(y_0 - \hat{f}(x_0))^2 = Var(\hat{f}(x_0)) + [Bias(\hat{f}(x_0))]^2 + Var(\epsilon)
\]</span></p>
<p>The term on the left side of this equation is the expected test MSE at a particular point <span class="math inline">\(x_0\)</span>​. The word “expected” here has a specific meaning: it refers to the average test MSE we would obtain if we were to repeat the entire process of collecting training data and fitting the model many times over. Each time we collect a new training dataset and fit a model, we would get a slightly different estimate <span class="math inline">\(\hat{f}\)</span>, and therefore a slightly different prediction error at <span class="math inline">\(x_0\)</span>​. The expected test MSE is the average of all these prediction errors across all possible training datasets we might have drawn. This decomposition tells us something profound. It says that the prediction error at any point is not a single monolithic quantity but rather the sum of three fundamentally different sources of error. To build good models, we need to understand each of these three components and how they relate to each other.</p>
<p><strong>1. Understanding Variance</strong></p>
<p>The first component is the variance of <span class="math inline">\(\hat{f}(x_0)\)</span>. Variance, in this context, refers to how much the model’s prediction at the point <span class="math inline">\(x_0\)</span>​ would change if we estimated the model using a different training dataset. Remember that the training data are a sample drawn from a larger population, and if we were to draw a different sample, we would get different data points and therefore a different estimated function <span class="math inline">\(\hat{f}\)</span>​. If a method has high variance, it means that small changes in the training data lead to large changes in the estimated function and therefore in the predictions the model produces. If a method has low variance, the predictions remain relatively stable regardless of which particular training dataset is used.</p>
<p>To understand this in the context of our income inequality example, imagine that the researcher conducts the same study multiple times, each time drawing a new random sample of one thousand individuals from the population. Each sample will contain slightly different people with slightly different combinations of education, occupation, region, family background, race, gender, work experience, and income. Now suppose the researcher fits the same type of model to each of these different samples. If the method has low variance, the predicted income for a person with, say, a university degree, a professional occupation, living in an urban area, from a middle-class family, who is a white male with ten years of work experience would be roughly similar regardless of which particular sample the model was trained on. The predictions would be stable and consistent across different training datasets. However, if the method has high variance, the predicted income for this same hypothetical person could change dramatically depending on which sample happened to be drawn. One sample might produce a prediction of 45,000 euros while another sample, drawn from the same population, might produce a prediction of 52,000 euros, and yet another might yield 39,000 euros. This instability in predictions is what we mean by high variance.</p>
<p>The crucial insight is that more flexible methods tend to have higher variance. The reason is intuitive. A highly flexible model can conform closely to the specific patterns in whatever training data it receives. This means it is highly sensitive to the particular observations in the training set. If one influential individual is replaced by another, the flexible model might change its predictions substantially because it was fitting so closely to each data point. In our income example, a very flexible model might learn intricate patterns specific to the particular one thousand people in the sample - perhaps noticing that in this specific dataset, people from a certain small region with a certain combination of education and experience earn unusually high incomes. If a different sample were drawn, this particular pattern would likely not reappear, and the model’s predictions would shift accordingly.</p>
<p>In contrast, a simple linear regression model has low variance because it is constrained to fit a straight-line relationship. Changing a few observations in the training data will only shift the line slightly. The predictions are stable because the model’s rigid structure prevents it from responding dramatically to the idiosyncrasies of any particular sample. Whether the researcher uses sample A or sample B, a linear model will produce roughly similar predictions, because it can only capture broad, linear trends that tend to be consistent across samples.</p>
<p><strong>2. Understanding Bias</strong></p>
<p>The second component of the expected test MSE is the squared bias of <span class="math inline">\(\hat{f}(x_0)\)</span>. Bias refers to the error that arises from approximating a real-world phenomenon, which may be very complex, with a simplified model. It measures the difference between the average prediction of our model (averaged over all possible training datasets) and the true value of the function <span class="math inline">\(f\)</span> at the point <span class="math inline">\(x_0\)</span>​. In other words, bias captures how far off our model is, on average, from the truth - not because of random fluctuations in the training data, but because the model itself is structurally incapable of capturing the true relationship.</p>
<p>Returning to the income inequality example, suppose that the true relationship between the seven predictors and adult income is genuinely complex. Perhaps the return to education is nonlinear, with relatively modest income gains for each additional year of schooling at lower levels but a sharp jump when a person completes a university degree. Perhaps there are important interactions between predictors - for instance, the effect of work experience on income might differ substantially depending on occupation, with experience mattering a great deal in some professions and very little in others. Perhaps the relationship between parental socioeconomic status and adult income is mediated in complex ways by education and region, creating patterns that cannot be captured by a simple additive model.</p>
<p>If the researcher uses a simple linear regression to model this complex reality, the model assumes that each predictor has a constant, additive effect on income. It cannot capture the sharp jump at university degree completion, it cannot represent the interaction between experience and occupation, and it cannot model the complex mediating role of family background. No matter how much training data the researcher collects, the linear model will systematically miss these features of the true relationship. This systematic error is bias. The model is biased because its structure is too simple to represent the truth. Even if the researcher could average the predictions across infinitely many training samples, the average prediction of the linear model would still differ from the true <span class="math inline">\(f\)</span> because the model is fundamentally incapable of representing the true relationship.</p>
<p>More flexible methods tend to have lower bias because they can adapt to a wider range of possible shapes for <span class="math inline">\(f\)</span>. A flexible model that allows for nonlinear effects and interactions would be better able to capture the true complexity of how education, occupation, family background, and other factors jointly determine income. If the model’s structure is rich enough, it can, in principle, approximate the true function <span class="math inline">\(f\)</span> very closely, resulting in low or even negligible bias.</p>
<p>The reason this concept is called a <strong>trade-off</strong> is that bias and variance tend to move in opposite directions as model flexibility changes. Simple, inflexible methods like linear regression have high bias because they impose strong assumptions about the form of <span class="math inline">\(f\)</span> that may not be accurate. But they have low variance because their rigid structure makes them resistant to fluctuations in the training data. Flexible methods, on the other hand, have low bias because they can adapt to complex patterns in the data, but they have high variance because they are sensitive to the specific observations in the training set.</p>
<p>The expected test MSE is the sum of variance, squared bias, and the irreducible error. The irreducible error, <span class="math inline">\(Var(\epsilon)\)</span>, is a constant that does not depend on the model at all - it represents the inherent unpredictability in the response that no model, no matter how sophisticated, can eliminate. In our income example, the irreducible error encompasses all the factors that influence income but are not captured by the seven predictors: individual personality traits, chance events, unmeasured forms of discrimination, health shocks, and countless other sources of variation. Since the irreducible error is fixed, the test MSE can only be reduced by managing the other two components: variance and bias.</p>
<p>As we increase flexibility, bias decreases. The model becomes better able to capture the true patterns in the data, and the systematic error introduced by an overly simplistic model structure diminishes. At the same time, variance increases. The model becomes more sensitive to the particular training data, and its predictions become less stable across different samples. The test MSE depends on the combined effect of these two opposing forces.</p>
<p>At low levels of flexibility, the model has high bias and low variance. The bias dominates the test MSE, and increasing flexibility helps because the reduction in bias is larger than the increase in variance. This is why the test MSE initially decreases as flexibility grows. In our income example, moving from a very rigid model - say, one that predicts the same average income for everyone regardless of their characteristics - to a basic linear regression would substantially reduce bias by allowing the model to capture at least the broad linear relationships between predictors and income. The test MSE would drop considerably because the improvement from lower bias far outweighs the modest increase in variance.</p>
<p>At moderate levels of flexibility, the model has found a good balance. It is flexible enough to capture the important patterns in the data but not so flexible that it is chasing noise. This is the point where the test MSE reaches its minimum, representing the best achievable predictive performance for the given set of predictors and the given type of model.</p>
<p>At high levels of flexibility, something changes. The bias has already been reduced to a low level, so further increases in flexibility yield only marginal improvements in bias. But variance continues to climb as the model becomes increasingly sensitive to the training data. Now the increase in variance outweighs the decrease in bias, and the test MSE begins to rise. The model is overfitting - it has become so flexible that it is learning noise rather than signal, and its predictions on new data suffer as a result.</p>
<p>This is why the test MSE exhibits the U-shape we discussed earlier. The left side of the U corresponds to high-bias, low-variance models that are too simple. The right side corresponds to low-bias, high-variance models that are too complex. The bottom of the U is the sweet spot where bias and variance are optimally balanced.</p>
<p>Let us trace through this trade-off more concretely using the income inequality study. Suppose the researcher considers a range of models of increasing flexibility. At the simplest extreme, imagine a model that simply predicts the overall average income in the training sample for every individual, regardless of their education, occupation, or any other characteristic. This model has essentially zero variance - it will produce nearly the same prediction no matter which training sample is drawn, because sample means are very stable. But it has enormous bias, because it completely ignores all the systematic relationships between the predictors and income. The test MSE would be very high, driven almost entirely by bias. Next, consider a standard linear regression that includes all seven predictors. This model can capture the average linear effect of education, occupation, region, family background, race, gender, and work experience on income. Compared to the naive average, it has substantially lower bias because it acknowledges that these factors matter and estimates their effects. Its variance is still relatively low because the linear structure constrains the model considerably. The test MSE would be much lower than that of the naive model. Now consider a more flexible model that allows for nonlinear effects - perhaps using polynomial terms or splines to model the relationship between years of education and income, or including interaction terms that allow the effect of work experience to vary by occupation. This model can capture important features of the true relationship that linear regression misses, such as the disproportionate returns to completing a university degree or the different career trajectories across occupations. The bias decreases further. The variance increases somewhat because the model now has more parameters to estimate and is more sensitive to the particular sample. If the true relationship genuinely contains these nonlinearities and interactions, the reduction in bias will outweigh the increase in variance, and the test MSE will decrease. However, if the researcher continues to increase flexibility - adding higher-order polynomial terms, three-way and four-way interactions between predictors, and extremely localized fits - the model begins to adapt to features of the training data that are not part of the true underlying relationship. Perhaps in this specific sample, there happen to be three individuals from a particular region who all have unusually high incomes, and the very flexible model adjusts its predictions for that region upward to accommodate these three people. In a new sample, this pattern would not recur, and the model’s predictions for that region would be systematically too high. The variance is now large, the bias gains from additional flexibility are negligible, and the test MSE starts climbing.</p>
<p><strong>3. The Irreducible Error as a Floor</strong></p>
<p>An important implication of the bias-variance decomposition is that there is a floor below which the test MSE can never fall, no matter how good our model is. This floor is the irreducible error, <span class="math inline">\(Var(\epsilon)\)</span>. In the income inequality example, even if we had a perfect model that captured every systematic relationship between the seven predictors and income, there would still be variation in income that these predictors cannot explain. Two individuals who are identical in terms of education, occupation, region, family background, race, gender, and work experience will still have different incomes, because of all the unmeasured factors that influence earnings. No model built from these seven predictors can predict this residual variation, and so the test MSE can never be reduced below this level.</p>
<p>This is an important reminder for social science researchers. The irreducible error is not a failure of the model - it is a reflection of the inherent complexity of social phenomena. Human income is influenced by a vast number of factors, and no finite set of predictors can account for all of them. The goal of statistical learning is not to eliminate all prediction error but to reduce the reducible portion of the error - the part driven by bias and variance - as much as possible.</p>
<p>The bias-variance trade-off has profound practical implications for anyone building statistical models in the social sciences. It tells us that the most complex model is not necessarily the best model. A researcher who uses an extremely flexible machine learning method to predict income might achieve a very low training MSE, but if the model has high variance, its predictions on new data could be poor. Conversely, a researcher who sticks with simple linear regression out of tradition might be leaving predictive accuracy on the table if the true relationships are genuinely nonlinear. The trade-off also explains why different datasets may require different levels of model flexibility. If the true relationship between predictors and the response is approximately linear - perhaps because the predictors have been carefully chosen and transformed - then a simple model will have low bias to begin with, and increasing flexibility will mainly add variance without much benefit. If, on the other hand, the true relationship is highly nonlinear and involves complex interactions, a simple model will have high bias, and the researcher needs to use a more flexible approach to capture the important patterns, accepting some increase in variance as the cost of reducing bias.</p>
<p>In real-life situations where the true <span class="math inline">\(f\)</span> is unknown - which is essentially always the case in practice - we cannot directly compute the bias, the variance, or even the test MSE. We cannot look at the decomposition and decide exactly where the optimal flexibility lies. Nevertheless, keeping the bias-variance trade-off in mind helps guide our thinking. It reminds us to be skeptical of models that fit the training data too perfectly, to consider whether our model might be too simple or too complex for the phenomenon at hand, and to use techniques like cross-validation to empirically estimate the test MSE and find a good balance between bias and variance.</p>
</section>
</section>
<section id="the-classification-setting" class="level3" data-number="1.3.2">
<h3 data-number="1.3.2" class="anchored" data-anchor-id="the-classification-setting"><span class="header-section-number">1.3.2</span> The Classification Setting</h3>
<p>Up to this point, our discussion of model accuracy has focused entirely on the regression setting, where the response variable is quantitative. However, many research questions in the social sciences involve response variables that are qualitative rather than quantitative. A qualitative response variable takes on values that represent discrete categories or classes rather than numerical quantities. The classification setting deals with precisely this kind of problem: predicting which category an observation belongs to, rather than predicting a numerical value.</p>
<p>The concepts we have already covered - the distinction between training and test performance, the danger of overfitting, and the bias-variance trade-off - all carry over to the classification setting. However, the specific measures we use to evaluate model performance need to be adapted, because it no longer makes sense to talk about squared differences between predicted and actual values when the response is a category rather than a number.</p>
<p>To make the classification setting concrete within our sociological example, let us modify the research question slightly. Instead of predicting how much a person earns, suppose the researcher is now interested in predicting whether a person will end up in a state of economic vulnerability or not. The researcher might define economic vulnerability as earning below a certain threshold - say, below 60 percent of the median national income, which is a commonly used measure of relative poverty risk in European social policy research. The response variable Y is now qualitative: for each individual, it takes one of two values, either “economically vulnerable” or “not economically vulnerable”. The predictors remain the same seven variables we have been working with: educational credentials (<span class="math inline">\(X_1\)</span>​), occupation (<span class="math inline">\(X_2\)</span>​), geographic region (<span class="math inline">\(X_3\)</span>​), parents’ socioeconomic status (<span class="math inline">\(X_4\)</span>), race (<span class="math inline">\(X_5\)</span>​), gender (<span class="math inline">\(X_6\)</span>​), and years of work experience (<span class="math inline">\(X_7\)</span>​). The research question is no longer about predicting the exact income a person will earn, but about classifying each individual into one of two categories based on their characteristics. This is a classification problem, and it requires different tools for measuring how well our model performs.</p>
<p>In the regression setting, we measured model performance using the mean squared error, which quantifies how far the predicted numerical values are from the actual numerical values. In the classification setting, the natural analogue is the <strong>error rate</strong>, which simply measures the proportion of observations that are incorrectly classified. The training error rate is computed by applying the model to the training data and counting the fraction of cases where the predicted class does not match the true class. Formally, this is expressed as:</p>
<p><span class="math display">\[
\frac{1}{n} \sum_{i=1}^{n} I(y_i \neq \hat{y}_i)
\]</span></p>
<p>In this formula, <span class="math inline">\(\hat{y}_i\)</span>​ is the class label that the model predicts for the <span class="math inline">\(i\)</span>-th observation, and <span class="math inline">\(I(y_i \neq \hat{y}_i)\)</span> is an indicator function that equals one whenever the prediction is wrong and zero whenever the prediction is correct. By summing these indicators across all observations and dividing by the total number of observations, we get the fraction of misclassifications - the training error rate.</p>
<p>In our example, suppose the researcher trains a classification model on data from one thousand individuals. The model predicts, for each person, whether they are economically vulnerable or not. If the model correctly classifies 920 of the 1,000 individuals and misclassifies 80, the training error rate is 80 divided by 1,000, which equals 0.08, or 8 percent. This means the model gets it wrong for 8 percent of the people in the training sample.</p>
<p>However, just as in the regression setting, the training error rate is not what we truly care about. What matters is the test error rate - the proportion of misclassifications when the model is applied to new observations that were not part of the training data. The test error rate is given by:</p>
<p><span class="math display">\[
Ave(I(y_0 \neq \hat{y}_0))
\]</span></p>
<p>This measures the average misclassification rate across test observations. A good classifier is one that achieves the smallest possible test error rate, meaning it correctly classifies the highest proportion of new, unseen individuals.</p>
<p>In our context, the researcher wants a model that can accurately predict economic vulnerability for future individuals - people who were not in the original training sample. Perhaps the model will be used to identify individuals at risk of poverty in a new survey wave, or to target social policy interventions toward those most likely to be economically vulnerable. The value of the model lies not in how well it classifies the one thousand people whose outcomes are already known, but in how well it classifies new individuals whose outcomes the researcher does not yet know.</p>
<section id="the-bayes-classifier" class="level4" data-number="1.3.2.1">
<h4 data-number="1.3.2.1" class="anchored" data-anchor-id="the-bayes-classifier"><span class="header-section-number">1.3.2.1</span> The Bayes Classifier</h4>
<p>The <strong>Bayes classifier</strong> represents the best possible classification rule - the one that produces the lowest possible test error rate. Understanding the Bayes classifier is important not because we can ever actually use it in practice, but because it provides a benchmark against which all real classification methods can be evaluated.</p>
<p>The Bayes classifier works on a deceptively simple principle: for each observation, assign it to the class that is most probable given its predictor values. Formally, for a test observation with predictor vector <span class="math inline">\(x_0\)</span>​, the Bayes classifier assigns the observation to the class <span class="math inline">\(j\)</span> for which the conditional probability <span class="math inline">\(Pr(Y = j \mid X = x_0)\)</span> is largest.</p>
<p>To understand what this means in our example, consider a specific individual - a woman with a university degree, working in a service occupation, living in a rural region, from a lower-middle-class family background, who is white and has five years of work experience. The Bayes classifier asks: <em>given this particular combination of characteristics, what is the probability that this person is economically vulnerable, and what is the probability that she is not?</em> If the probability of being economically vulnerable given her specific profile is 0.25, and the probability of not being economically vulnerable is 0.75, then the Bayes classifier assigns her to the “not economically vulnerable” category, because that is the more probable outcome for someone with her characteristics.</p>
<p>In a two-class problem like ours - where the response is either “economically vulnerable” or “not economically vulnerable” - the Bayes classifier reduces to a simple rule: classify the individual as economically vulnerable if the probability of economic vulnerability given their predictor values exceeds 0.5, and classify them as not economically vulnerable otherwise. The boundary in predictor space where the probability of each class is exactly equal — where <span class="math inline">\(Pr(Y = vulnerable \mid X = x_0) = 0.5\)</span> - is called the <strong>Bayes decision boundary</strong>. On one side of this boundary, individuals are classified as vulnerable; on the other side, they are classified as not vulnerable.</p>
<p>The Bayes classifier produces the lowest possible test error rate, called the <strong>Bayes error rate</strong>. This rate is given by:</p>
<p><span class="math display">\[
1 - E\left(\max_j \Pr(Y = j \mid X)\right)
\]</span></p>
<p>The Bayes error rate is greater than zero whenever there is any overlap between the classes in the population - that is, whenever there exist regions of the predictor space where neither class has a probability of one. In our example, this overlap is substantial. Even among people with very similar educational credentials, occupations, and family backgrounds, some will be economically vulnerable and others will not, because of all the unmeasured factors that influence income. No classifier, no matter how sophisticated, can perfectly separate the two groups based on the seven predictors alone. The Bayes error rate represents this fundamental limit on classification accuracy, and it is directly analogous to the irreducible error in the regression setting.</p>
<p>The reason the Bayes classifier cannot be used in practice is that it requires perfect knowledge of the conditional probabilities <span class="math inline">\(Pr(Y = j \mid X = x_0)\)</span> for every possible combination of predictor values. In the real world, we never know these probabilities. We only have sample data from which we can try to estimate these probabilities. The Bayes classifier therefore serves as a theoretical gold standard - an ideal that real methods try to approximate but can never fully achieve.</p>
</section>
<section id="k-nearest-neighbors" class="level4" data-number="1.3.2.2">
<h4 data-number="1.3.2.2" class="anchored" data-anchor-id="k-nearest-neighbors"><span class="header-section-number">1.3.2.2</span> K-Nearest Neighbors</h4>
<p>Since the Bayes classifier is unattainable in practice, we need real methods that can approximate it using available data. One such method is the <strong>K-nearest neighbors classifier</strong>, commonly abbreviated as KNN. The KNN classifier is a conceptually simple approach that directly attempts to estimate the conditional probabilities that the Bayes classifier relies on, and then classifies each observation to the class with the highest estimated probability.</p>
<p>The KNN classifier works as follows. Given a positive integer K and a new observation <span class="math inline">\(x_0\)</span>​ that we want to classify, the algorithm first identifies the K training observations that are closest to <span class="math inline">\(x_0\)</span>​ in the predictor space. This set of K nearest neighbors is denoted <span class="math inline">\(\mathcal{N}_0\)</span>​. The classifier then estimates the conditional probability for each class as the proportion of those K neighbors that belong to that class:</p>
<p><span class="math display">\[
\Pr(Y = j \mid X = x_0) = \frac{1}{K} \sum_{i \in \mathcal{N}_0} I(y_i = j)
\]</span></p>
<p>Finally, KNN assigns the test observation <span class="math inline">\(x_0\)</span>​ to the class with the largest estimated probability.</p>
<p>To see how this works in our income inequality example, suppose the researcher wants to predict whether a new individual - let us call her Person A - is economically vulnerable or not. Person A has a specific set of characteristics: a vocational degree, a clerical occupation, living in a mid-sized city, from a working-class family, who is a white woman with three years of work experience. The KNN classifier, with, say, <span class="math inline">\(K = 5\)</span>, would search through the entire training dataset of one thousand individuals and find the five people whose combination of education, occupation, region, family background, race, gender, and work experience is most similar to Person A’s profile. Perhaps among these five nearest neighbors, three are not economically vulnerable and two are economically vulnerable. The estimated probability of being not vulnerable is then 3/5, or 0.6, and the estimated probability of being vulnerable is 2/5, or 0.4. Since 0.6 is greater than 0.5, KNN classifies Person A as not economically vulnerable.</p>
<p>The intuition behind KNN is that people with similar characteristics tend to have similar outcomes. If most of the people in the training data who resemble Person A are not economically vulnerable, then it is reasonable to predict that Person A is also not economically vulnerable. This is a form of learning from analogy - the algorithm classifies new cases by looking at the outcomes of the most similar known cases.</p>
<p>The value of K - the number of neighbors considered - is a crucial parameter that profoundly affects the behavior of the KNN classifier. The choice of K determines where the classifier falls on the flexibility spectrum and therefore directly influences the bias-variance trade-off. When K is very small, say <span class="math inline">\(K = 1\)</span>, the classifier is extremely flexible. It classifies each new observation based on the single most similar training observation. This means the decision boundary - the line separating the region where the model predicts vulnerability from the region where it predicts non-vulnerability - is highly irregular, twisting and turning to accommodate the class label of every individual training observation. With <span class="math inline">\(K = 1\)</span>, the training error rate is actually zero, because each training observation is its own nearest neighbor, so the model always correctly classifies every observation in the training set. However, this impressive training performance is misleading. The model has effectively memorized the training data, including all of its noise and idiosyncrasies. When applied to new data, many of these intricate local patterns will not hold up, and the test error rate will be considerably higher than zero.</p>
<p>In our example, using <span class="math inline">\(K = 1\)</span> would mean that the classification of a new individual depends entirely on which single person in the training data happens to have the most similar profile. If that nearest neighbor happens to be an unusual case - perhaps someone who is economically vulnerable despite having relatively favorable characteristics, due to some unmeasured factor like a health crisis - the model would make an incorrect prediction. With <span class="math inline">\(K = 1\)</span>, the classifier has very low bias because it imposes almost no assumptions about the shape of the true decision boundary, but it has very high variance because the prediction for any new observation can change dramatically depending on which particular training observations happen to be closest.</p>
<p>When K is very large, the classifier becomes much less flexible. With a large K, the model averages over many training observations to make each prediction, which smooths out the local fluctuations and produces a decision boundary that is much more stable. However, if K is too large, the classifier becomes overly rigid. In the extreme case where K equals the total number of training observations, the classifier would simply predict the majority class for every new observation, ignoring the predictor values entirely. This would have very low variance - the prediction would be the same regardless of which training data were used - but very high bias, because it ignores all the information contained in the predictors.</p>
<p>In our example, using a very large K, say <span class="math inline">\(K = 100\)</span>, would mean that the prediction for each new individual is based on the outcomes of the 100 most similar people in the training data. This large neighborhood includes people who may not actually be very similar to the individual being classified, and the resulting prediction is essentially an average over a broad swath of the population. The decision boundary becomes very smooth, almost linear, and the model loses its ability to capture local patterns in the data - such as the fact that certain specific combinations of low education, unstable occupation, and disadvantaged family background are particularly strong predictors of economic vulnerability.</p>
<p>Finall, neither extreme or very large K tends to produce good test error rates. With <span class="math inline">\(K = 1\)</span>, the classifier overfits by being too responsive to individual data points. With very large K, the classifier underfits by being too insensitive to meaningful patterns. The best test performance is typically achieved at an intermediate value of K that balances the competing demands of bias and variance. In the simulated example presented in the chapter, <span class="math inline">\(K = 10\)</span> produced a test error rate very close to the theoretical minimum set by the Bayes error rate, illustrating that a well-chosen KNN classifier can approximate the unattainable Bayes classifier remarkably well.</p>
<p>Just as in the regression setting, the test error rate in the classification setting follows the characteristic U-shape as model flexibility varies. For KNN, flexibility is inversely related to K: small values of K correspond to high flexibility, and large values of K correspond to low flexibility. To make the analogy with the regression plots clearer, the chapter plots the error rates as a function of <span class="math inline">\(1/K\)</span>, so that moving to the right on the horizontal axis corresponds to increasing flexibility.</p>
<p>As <span class="math inline">\(1/K\)</span> increases from near zero toward one - that is, as K decreases from very large values toward one - the training error rate steadily declines, eventually reaching zero at <span class="math inline">\(K = 1\)</span>. This mirrors what we saw in the regression setting: more flexible models always fit the training data better. However, the test error rate does not follow the training error rate downward. Instead, it decreases initially as the classifier becomes flexible enough to capture the important patterns separating the two classes, reaches a minimum at some intermediate level of flexibility, and then increases as the classifier becomes so flexible that it starts overfitting to noise in the training data.</p>
<p>In our economic vulnerability example, this means that the researcher would find that a moderately flexible KNN classifier - one that considers a reasonable number of neighbors rather than too few or too many - produces the most accurate predictions for new individuals. Using too few neighbors leads to erratic predictions driven by the particular circumstances of a handful of similar individuals in the training data. Using too many neighbors washes out the meaningful differences between people with different risk profiles, producing predictions that are too uniform.</p>
<p>The classification setting reinforces the same fundamental lessons we learned in the regression setting. First, training performance is an unreliable guide to how well a model will perform on new data. A classifier that achieves a very low training error rate may be overfitting, memorizing the training data rather than learning generalizable patterns. Second, the bias-variance trade-off applies to classification just as it applies to regression. Simple classifiers have high bias and low variance, flexible classifiers have low bias and high variance, and the best test performance lies somewhere in between. Third, there exists a theoretical limit on how well any classifier can perform - the Bayes error rate - that is determined by the inherent overlap between the classes in the population and by the information content of the available predictors.</p>
<p>For research on economic vulnerability, this means that no model built from the seven predictors we have considered can perfectly classify every individual. Some people with seemingly favorable characteristics will nonetheless be economically vulnerable, and some with seemingly unfavorable characteristics will not be. The irreducible error reflects the complexity of social life - the fact that economic outcomes are shaped by a multitude of factors, many of which cannot be captured in any feasible set of measured variables. The goal of the researcher is not to eliminate this irreducible uncertainty but to build a classifier that comes as close as possible to the Bayes ideal, capturing the genuine patterns in the data without being misled by noise.</p>


<!-- -->

</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
    const viewSource = window.document.getElementById('quarto-view-source') ||
                       window.document.getElementById('quarto-code-tools-source');
    if (viewSource) {
      const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
      viewSource.addEventListener("click", function(e) {
        if (sourceUrl) {
          // rstudio viewer pane
          if (/\bcapabilities=\b/.test(window.location)) {
            window.open(sourceUrl);
          } else {
            window.location.href = sourceUrl;
          }
        } else {
          const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
          modal.show();
        }
        return false;
      });
    }
    function toggleCodeHandler(show) {
      return function(e) {
        const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
        for (let i=0; i<detailsSrc.length; i++) {
          const details = detailsSrc[i].parentElement;
          if (show) {
            details.open = true;
          } else {
            details.removeAttribute("open");
          }
        }
        const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
        const fromCls = show ? "hidden" : "unhidden";
        const toCls = show ? "unhidden" : "hidden";
        for (let i=0; i<cellCodeDivs.length; i++) {
          const codeDiv = cellCodeDivs[i];
          if (codeDiv.classList.contains(fromCls)) {
            codeDiv.classList.remove(fromCls);
            codeDiv.classList.add(toCls);
          } 
        }
        return false;
      }
    }
    const hideAllCode = window.document.getElementById("quarto-hide-all-code");
    if (hideAllCode) {
      hideAllCode.addEventListener("click", toggleCodeHandler(false));
    }
    const showAllCode = window.document.getElementById("quarto-show-all-code");
    if (showAllCode) {
      showAllCode.addEventListener("click", toggleCodeHandler(true));
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./index.html" class="pagination-link" aria-label="Preface">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Preface</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./linear_regression.html" class="pagination-link" aria-label="Linear Regression">
        <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Linear Regression</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "Introduction to Statistical Learning"</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="an">description:</span><span class="co"> ""</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="an">number-sections:</span><span class="co"> true</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="an">title-block-banner:</span><span class="co"> "#00868B"</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="an">title-block-banner-color:</span><span class="co"> "white"</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>**Statistical learning** refers to a broad set of approaches and techniques for estimating the function that connects independent variables to an dependent variable. At its core, statistical learning is concerned with understanding the relationship between variables and using that understanding either to make predictions about future observations or to gain insight into how different factors influence an outcome.</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="fu">## Statistical Learning Formula</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>The fundamental idea of statistical learning can be expressed through a simple formula:</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>$Y = f(X) + \epsilon$</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>This formula tells us that any outcome we wish to study or predict can be understood as the result of some systematic relationship between independent and dependent variables, plus some random variation that we cannot fully explain or control. The goal of statistical learning is to estimate the function $f$ based on observed data, so that we can either predict Y for new observations or understand how changes in X are associated with changes in Y.</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>Let's now explain each component of this formula in detail.</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The **dependent variable** or response, denoted by **Y**, represents the response that we are trying to understand, explain, or predict. This is the variable whose variation we want to account for using other available information. It is called *dependent* precisely because its values depend on, or are influenced by, other variables in the system we are studying.</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The **independent variable** or predictor, denoted by **X**, represents the input information that we use to explain or predict the outcome. In most realistic situations, we have multiple predictors rather than just one, so X typically represents a collection of variables written as $X = (X_1, X_2, ..., X_p)$, where $X_p$ indicates the total number of predictors. The key characteristic of predictors is that they provide information that helps us understand or anticipate the values of the dependent variable.</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The function **$f$** represents the **systematic relationship between the dependent variable and the indipendent variable**. This function captures all the information that the independent variables collectively provide about the dependent variable. In other words, $f$ describes the pattern or rule that connects predictors to response in a consistent, reproducible way. The crucial point is that in real-world applications, the true form of $f$ is almost always unknown to us. We never directly observe this function; instead, we must estimate it based on the data we have collected. The entire enterprise of statistical learning revolves around developing methods to estimate $f$ as accurately as possible.</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The **error term**, denoted by **$\epsilon$**, represents the random component of the relationship between dependent and independent variables. This term captures all the variation in Y that cannot be explained by the $X_p$. The error term is assumed to be independent of X and to have a mean of zero, which means that on average, the errors cancel out and do not systematically bias our predictions in one direction or another. The error term exists for several important reasons.</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>First, there may be variables that influence dependent variable but that we have not measured or included in our analysis.</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>Second, even if we could measure every relevant variable, there might be inherent randomness or unpredictability in the phenomenon we are studying.</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>Third, our measurements themselves may contain some degree of imprecision or noise.</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>To make these concepts concrete, let me illustrate them with the example. Consider a researcher studying income inequality and social mobility. The researcher might want to understand what determines a person's income in adulthood. The dependent variable Y would be adult income, measured in monetary units. The predictors X might encompass the person's own educational credentials, their occupation, the region where they live, their parents' socioeconomic status, their race and gender, and the number of years of work experience they have accumulated. The function $f$ would capture the systematic relationships between these characteristics and income, revealing how the labor market rewards different attributes and how social background continues to influence economic outcomes across generations. The error term $\epsilon$ would account for all the variation in income that these measured factors cannot explain. This residual variation might stem from unmeasured differences in job performance, luck in finding particularly good or bad employment matches, health shocks that affect earning capacity, or discrimination that varies in ways not captured by the measured variables.</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>We can write this relationship as: $Y\ =\ f(X_1,\ X_2,\ X_3,\ X_4,\ X_5,\ X_6,\ X_7)\ +\ ϵ$</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>In this formula, Y represents adult income measured in monetary units such as annual earnings in euros. This is the response we are trying to understand or predict. The predictors are defined as follows.</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$X_1$ represents the person's educational credentials, which might be measured as years of schooling completed or as the highest degree obtained.</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$X_2$ represents occupation, which could be coded as occupational prestige scores or as categorical indicators for different types of jobs.</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$X_3$ represents the geographic region where the person lives and works, capturing spatial variation in labor markets and cost of living.</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$X_4$ represents parents' socioeconomic status, which might be measured through parental income, parental education, or a composite index combining multiple indicators of family background.</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$X_5$ represents race, coded as categorical indicators for different racial or ethnic groups.</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$X_6$ represents gender, typically coded as a binary or categorical variable.</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$X_7$ represents years of work experience, measuring how long the person has been participating in the labor force.</span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>The function $f$ captures the systematic relationship between all these predictors and adult income. This function describes how the labor market values different combinations of education, occupation, location, background, and demographic characteristics. The precise form of $f$ is unknown to us and must be estimated from data. It might be relatively simple, such as a linear combination of the predictors, or it might be quite complex, involving interactions between variables and nonlinear relationships.</span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>The error term $\epsilon$ represents all the variation in adult income that cannot be explained by the seven predictors we have included. This encompasses unmeasured factors such as individual differences in productivity, motivation, and interpersonal skills, as well as random events like fortunate or unfortunate timing in job searches, health events that affect earning capacity, and idiosyncratic experiences of discrimination or favoritism in the workplace, and so on.</span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a><span class="fu">## Relationship between Dependent and Independent Variable</span></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>The function $f$ is the central object of interest in statistical learning. It represents the systematic relationship between the independent variable and the dependent variable, capturing all the information that the independent variables provide about the dependent variable. When we say that $Y = f(X) + \epsilon$, we are asserting that the response can be decomposed into two parts: a predictable component $f(X)$ that depends on the values of the predictors, and an unpredictable component $\epsilon$ that represents random variation. The function $f$ is what connects the world of responses to the world of predictors in a consistent, reproducible manner.</span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>Understanding the nature of $f$ is crucial because it embodies the underlying pattern that governs how changes in the independent variable translate into changes in the dependent variable. If we knew $f$ perfectly, we would understand exactly how each predictor influences the response, how predictors interact with one another, and what response to expect for any given combination of predictor values. However, in virtually all real-world applications, $f$ is unknown. We never observe $f$ directly; we only observe data points consisting of predictor values and corresponding responses. The entire purpose of statistical learning is to use these observed data points to construct an estimate of $f$, which we denote as $\hat{f}$. The reasons we might want to estimate $f$ fall into two broad categories: prediction and inference. These two goals are conceptually distinct, and they often lead us to prefer different types of statistical learning methods.</span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>**Prediction** is concerned with accurately anticipating the value of Y for new observations where we know the predictors X but do not yet know the response of the predictors. In prediction tasks, we treat $\hat{f}$ as a kind of black box. We do not necessarily care about the internal workings of our estimated function or about which specific predictors matter most. What we care about is whether our estimate $\hat{f}$ produces accurate predictions when applied to new data. The quality of predictions depends on two sources of error:</span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>The first is **reducible error**, which arises because our estimate $\hat{f}$ is imperfect and does not exactly match the true $f$. We can potentially reduce this error by using better statistical learning methods or by collecting more data.</span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>The second is **irreducible error**, which corresponds to the variance of $\epsilon$. Even if we had a perfect estimate of $f$, our predictions would still contain some error because Y is inherently influenced by random factors that cannot be predicted from X alone.</span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a>**Inference**, by contrast, is concerned with understanding the relationship between the predictors and the outcome. When our goal is inference, we cannot treat $\hat{f}$ as a black box because we need to know its exact form. We want to answer questions such as which predictors are associated with the response, what is the direction and magnitude of each predictor's effect, and whether the relationships are linear or more complex. Inference requires that our estimate $\hat{f}$ be interpretable, meaning that we can examine it and draw substantive conclusions about how the world works.</span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>In practice, many research projects involve elements of both prediction and inference. A researcher studying income might want to understand the determinants of earnings while also developing a model that can predict incomes for new individuals. However, there is often tension between these goals because the methods that produce the most accurate predictions are not always the most interpretable, and the most interpretable methods do not always produce the best predictions.</span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a><span class="fu">### Parametric vs non-parametric methods</span></span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>Having established why we want to estimate $f$, let us now turn to the question of how we estimate $f$. Statistical learning methods for estimating $f$ can be broadly divided into two categories: parametric methods and non-parametric methods. These two approaches differ fundamentally in the assumptions they make about the form of $f$ and in the way they use data to construct an estimate.</span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a>**Parametric methods** proceed in two steps. In the first step, we make an assumption about the functional form of $f$. That is, we specify in advance what kind of mathematical relationship we believe connects the predictors to the outcome. The most common assumption is that $f$ is linear, meaning that we assume the relationship can be written as $f(X) = \beta_0 + \beta_1X_1 + \beta_2X_2 + ... + \beta_pX_p$. This linear model asserts that the response is a weighted sum of the predictors, where the weights $\beta_1, \beta_2, ..., \beta_p$ are unknown coefficients that quantify the contribution of each predictor, and $\beta_0$ is an intercept term representing the expected response when all predictors equal zero. By assuming a linear form, we have dramatically simplified the problem. Instead of having to estimate an arbitrary, potentially very complex function $f$, we only need to estimate the intercept and the p coefficients. In the second step of the parametric approach, we use the observed data to fit or train the model. This means finding values of the parameters that make the model match the data as closely as possible. For the linear model, the most common fitting procedure is ordinary least squares, which chooses the parameter values that minimize the sum of squared differences between the observed responses and the responses predicted by the model. Once we have estimated the parameters, our estimate $\hat{f}$ is fully specified, and we can use it for prediction or inference.</span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a>The parametric approach has several important advantages. Because we have reduced the problem to estimating a fixed number of parameters, parametric methods are computationally efficient and can work well even with relatively small samples. Furthermore, the resulting models are typically easy to interpret. In a linear model, each coefficient tells us how much the expected responses changes when the corresponding predictor increases by one unit, holding all other predictors constant. This interpretability makes parametric models particularly valuable for inference. However, parametric methods also have a significant limitation. The assumption we make about the form of $f$ may be wrong. If the true relationship between the predictors and the response is nonlinear or involves complex interactions, a linear model will fail to capture these features and will provide a poor approximation to $f$. We can try to address this problem by using more flexible parametric models that include polynomial terms, interaction effects, or other elaborations of the basic linear form. But as we make our parametric model more flexible, we must estimate more parameters, which requires more data and increases the risk of a phenomenon called overfitting. **Overfitting** occurs when a model fits the training data very well but performs poorly on new data because it has captured random noise rather than genuine patterns. The model essentially memorizes the idiosyncrasies of the particular sample rather than learning the underlying relationship.</span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a>**Non-parametric methods** take a fundamentally different approach. Instead of assuming a specific functional form for $f$, non-parametric methods seek an estimate that gets close to the data points without imposing strong prior assumptions about the shape of the relationship. The idea is to let the data speak for themselves and to allow $\hat{f}$ to take whatever form best fits the observed patterns. One example of a non-parametric method is the thin-plate spline, which estimates $f$ as a smooth surface that passes near the observed data points. The analyst does not specify in advance that $f$ should be linear or quadratic or any other particular form. Instead, the method finds a smooth function that fits the data well, subject to some constraint on how wiggly or rough the function is allowed to be. Another example is the k-nearest neighbors method, which predicts the outcome for a new observation by averaging the outcomes of the k training observations that are most similar to it in terms of the predictor values.</span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a>The main advantage of non-parametric methods is their flexibility. Because they do not assume a particular form for $f$, they can potentially capture a much wider range of relationships, including highly nonlinear patterns and complex interactions that would be missed by a simple parametric model. If the true $f$ has an unusual or complicated shape, a non-parametric method has a better chance of approximating it accurately. However, non-parametric methods also have important disadvantages. Because they do not reduce the problem to estimating a small number of parameters, they typically require much larger samples to produce accurate estimates. The flexibility that allows non-parametric methods to fit complex patterns also makes them prone to overfitting, especially when sample sizes are limited. Furthermore, the estimates produced by non-parametric methods are often difficult to interpret. A non-parametric prediction does not come with coefficients that tell us how each predictor contributes to the outcome. This lack of interpretability makes non-parametric methods less useful for inference, even when they excel at prediction.</span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a>The choice between parametric and non-parametric methods involves a fundamental trade-off. Parametric methods impose structure on the problem, which makes estimation easier and results more interpretable, but at the cost of potentially misspecifying the true form of $f$. Non-parametric methods avoid this misspecification risk by staying flexible, but they require more data and produce less interpretable results. In practice, the best choice depends on the goals of the analysis, the amount of data available, and how much prior knowledge we have about the likely form of the relationship.</span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a>This brings us to a closely related issue: the trade-off between prediction accuracy and model interpretability. In statistical learning, there is often an inverse relationship between how flexible a method is and how interpretable its results are. Methods that impose strong restrictions on the form of $f$ tend to be highly interpretable but may not fit complex patterns very well. Methods that are highly flexible can capture intricate relationships but produce results that are difficult for humans to understand.</span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a>At one end of the spectrum, we have highly restrictive methods like linear regression and its close relatives. Linear regression assumes that $f$ is a linear combination of the predictors, which is a very strong restriction. This restriction means that linear regression can only produce straight lines in one dimension, flat planes in two dimensions, and hyperplanes in higher dimensions. The advantage is that the results are extremely interpretable. Each coefficient has a clear meaning: it tells us the expected change in Y associated with a one-unit increase in the corresponding predictor, holding other predictors constant. We can examine the coefficients and immediately understand which predictors matter, how large their effects are, and in which direction they operate. For inference purposes, this interpretability is invaluable.</span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a>Moving along the spectrum toward greater flexibility, we encounter methods like generalized additive models, which relax the linearity assumption by allowing each predictor to have a potentially nonlinear effect on the response, while still maintaining an additive structure. These models are more flexible than linear regression and can capture curved relationships, but they remain reasonably interpretable because we can plot and examine the estimated effect of each predictor separately. Further along the spectrum, we find decision trees, which partition the predictor space into regions and assign a predicted response to each region. Trees are moderately flexible and can capture interactions and nonlinearities, but they remain somewhat interpretable because we can visualize the tree structure and see which predictors are used to make splits and at what values. These methods can approximate extremely complex functions and often achieve superior predictive accuracy on difficult problems. However, their results are very hard to interpret.</span>
<span id="cb1-94"><a href="#cb1-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-95"><a href="#cb1-95" aria-hidden="true" tabindex="-1"></a>One might think that we should always prefer the most flexible method available, reasoning that greater flexibility means better ability to capture the true $f$. Surprisingly, this is not the case. More flexible methods are not always better, even when our sole goal is prediction. The reason is overfitting. A highly flexible method can fit the training data very closely, including the random noise in that particular sample. When we apply the model to new data, the noise patterns will be different, and the overfitted model will perform poorly. In many situations, a simpler, more restrictive model that does not fit the training data as closely will actually generalize better to new observations.</span>
<span id="cb1-96"><a href="#cb1-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-97"><a href="#cb1-97" aria-hidden="true" tabindex="-1"></a>This phenomenon is especially important when sample sizes are limited. With a small sample, there is not enough information to reliably estimate a complex, flexible model, and the risk of overfitting is high. In such cases, imposing structure through a parametric model can actually improve predictive performance by preventing the model from chasing noise. As sample sizes grow larger, we can afford to use more flexible methods because there is enough information to distinguish genuine patterns from random variation.</span>
<span id="cb1-98"><a href="#cb1-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-99"><a href="#cb1-99" aria-hidden="true" tabindex="-1"></a><span class="fu">### Supervised vs unsupervised learning</span></span>
<span id="cb1-100"><a href="#cb1-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-101"><a href="#cb1-101" aria-hidden="true" tabindex="-1"></a>To complete the overview of the foundational concepts in statistical learning, we need to understand additional distinction between supervised and unsupervised learning that help us categorize different types of learning problems.</span>
<span id="cb1-102"><a href="#cb1-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-103"><a href="#cb1-103" aria-hidden="true" tabindex="-1"></a>**Supervised learning** refers to situations where for each observation in our dataset, we have both predictor measurements and a corresponding response measurement. The term *supervised* reflects the idea that the learning process is guided or supervised by the known dependent variables. We observe what actually happened for each case in our training data, and we use this information to learn the relationship between independent variables and dependent variable. All the methods we have discussed so far fall into the supervised learning category when applied to problems where outcomes are observed. The fundamental goal of supervised learning is to build a model that can predict the response for new observations based on their predictor values, or to understand how the predictors relate to the response. In social sciences research, most studies involve supervised learning because we typically have data on both the explanatory variables and the outcome of interest. For example, when we study the relationship between education and income, we observe both variables for the individuals in our sample, which allows us to estimate how education influences earnings.</span>
<span id="cb1-104"><a href="#cb1-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-105"><a href="#cb1-105" aria-hidden="true" tabindex="-1"></a>**Unsupervised learning** describes a fundamentally different situation where we observe predictor measurements for each observation but have no corresponding response variable. Without a dependent variable to predict or explain, we cannot fit a regression model or train a classifier. Instead, unsupervised learning seeks to discover patterns, structures, or groupings within the data itself. The most common unsupervised learning task is cluster analysis, which attempts to identify subgroups of observations that are similar to one another. For instance, a researcher might have survey data containing many variables about people's attitudes, behaviors, and demographic characteristics, but no predefined categorization of people into types. Cluster analysis could reveal that the respondents naturally fall into distinct groups based on their patterns of responses, perhaps identifying clusters that correspond to different lifestyles, political orientations, or consumption patterns. The key feature of unsupervised learning is that there is no correct answer to supervise the learning process. We are not trying to predict a known outcome but rather to uncover hidden structure in the data. This makes unsupervised learning more exploratory and somewhat more subjective than supervised learning, since there is no objective criterion like prediction accuracy to evaluate whether we have found the right structure.</span>
<span id="cb1-106"><a href="#cb1-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-107"><a href="#cb1-107" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> Method <span class="pp">|</span> Unsupervised / Supervised <span class="pp">|</span> Parametric / Non-parametric <span class="pp">|</span> Flexibility <span class="pp">|</span> Interpretability <span class="pp">|</span> Best Suited For <span class="pp">|</span></span>
<span id="cb1-108"><a href="#cb1-108" aria-hidden="true" tabindex="-1"></a><span class="pp">|--------------|---------------------|-------------------|------------------|-----------------|</span></span>
<span id="cb1-109"><a href="#cb1-109" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> Linear Regression <span class="pp">|</span> Supervised <span class="pp">|</span> Parametric <span class="pp">|</span> Low <span class="pp">|</span> High <span class="pp">|</span> Inference <span class="pp">|</span></span>
<span id="cb1-110"><a href="#cb1-110" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> Ridge Regression <span class="pp">|</span> Supervised <span class="pp">|</span> Parametric <span class="pp">|</span> Low <span class="pp">|</span> High <span class="pp">|</span> Inference &amp; Prediction <span class="pp">|</span></span>
<span id="cb1-111"><a href="#cb1-111" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> Lasso <span class="pp">|</span> Supervised <span class="pp">|</span> Parametric <span class="pp">|</span> Low <span class="pp">|</span> High <span class="pp">|</span> Inference &amp; Prediction <span class="pp">|</span></span>
<span id="cb1-112"><a href="#cb1-112" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> Logistic Regression <span class="pp">|</span> Supervised <span class="pp">|</span> Parametric <span class="pp">|</span> Low <span class="pp">|</span> High <span class="pp">|</span> Inference <span class="pp">|</span></span>
<span id="cb1-113"><a href="#cb1-113" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> Generalized Additive Models <span class="pp">|</span> Supervised <span class="pp">|</span> Parametric (additive structure) <span class="pp">|</span> Medium <span class="pp">|</span> Medium-High <span class="pp">|</span> Inference &amp; Prediction <span class="pp">|</span></span>
<span id="cb1-114"><a href="#cb1-114" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> Decision Trees <span class="pp">|</span> Supervised <span class="pp">|</span> Non-parametric <span class="pp">|</span> Medium <span class="pp">|</span> Medium <span class="pp">|</span> Inference &amp; Prediction <span class="pp">|</span></span>
<span id="cb1-115"><a href="#cb1-115" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> Bagging <span class="pp">|</span> Supervised <span class="pp">|</span> Non-parametric <span class="pp">|</span> High <span class="pp">|</span> Low <span class="pp">|</span> Prediction <span class="pp">|</span></span>
<span id="cb1-116"><a href="#cb1-116" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> Random Forests <span class="pp">|</span> Supervised <span class="pp">|</span> Non-parametric <span class="pp">|</span> High <span class="pp">|</span> Low <span class="pp">|</span> Prediction <span class="pp">|</span></span>
<span id="cb1-117"><a href="#cb1-117" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> Boosting <span class="pp">|</span> Supervised <span class="pp">|</span> Non-parametric <span class="pp">|</span> High <span class="pp">|</span> Low <span class="pp">|</span> Prediction <span class="pp">|</span></span>
<span id="cb1-118"><a href="#cb1-118" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> Linear Support Vector Machines <span class="pp">|</span> Supervised <span class="pp">|</span> Parametric <span class="pp">|</span> Low-Medium <span class="pp">|</span> Medium <span class="pp">|</span> Prediction &amp; Inference <span class="pp">|</span></span>
<span id="cb1-119"><a href="#cb1-119" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> Nonlinear Support Vector Machines <span class="pp">|</span> Supervised <span class="pp">|</span> Non-parametric <span class="pp">|</span> High <span class="pp">|</span> Low <span class="pp">|</span> Prediction <span class="pp">|</span></span>
<span id="cb1-120"><a href="#cb1-120" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> K-Nearest Neighbors <span class="pp">|</span> Supervised <span class="pp">|</span> Non-parametric <span class="pp">|</span> High <span class="pp">|</span> Low <span class="pp">|</span> Prediction <span class="pp">|</span></span>
<span id="cb1-121"><a href="#cb1-121" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> Neural Networks <span class="pp">|</span> Supervised <span class="pp">|</span> Non-parametric <span class="pp">|</span> Very High <span class="pp">|</span> Very Low <span class="pp">|</span> Prediction <span class="pp">|</span></span>
<span id="cb1-122"><a href="#cb1-122" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> Deep Learning <span class="pp">|</span> Supervised <span class="pp">|</span> Non-parametric <span class="pp">|</span> Very High <span class="pp">|</span> Very Low <span class="pp">|</span> Prediction <span class="pp">|</span></span>
<span id="cb1-123"><a href="#cb1-123" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> K-Means Clustering <span class="pp">|</span> Unsupervised <span class="pp">|</span> Non-parametric <span class="pp">|</span> Medium <span class="pp">|</span> Medium <span class="pp">|</span> Discovering groups in data <span class="pp">|</span></span>
<span id="cb1-124"><a href="#cb1-124" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> Hierarchical Clustering <span class="pp">|</span> Unsupervised <span class="pp">|</span> Non-parametric <span class="pp">|</span> Medium <span class="pp">|</span> Medium-High <span class="pp">|</span> Discovering nested group structures <span class="pp">|</span></span>
<span id="cb1-125"><a href="#cb1-125" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> Principal Component Analysis <span class="pp">|</span> Unsupervised <span class="pp">|</span> Parametric <span class="pp">|</span> Low <span class="pp">|</span> Medium-High <span class="pp">|</span> Dimensionality reduction <span class="pp">|</span></span>
<span id="cb1-126"><a href="#cb1-126" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span> Factor Analysis <span class="pp">|</span> Unsupervised <span class="pp">|</span> Parametric <span class="pp">|</span> Low <span class="pp">|</span> High <span class="pp">|</span> Identifying latent constructs <span class="pp">|</span></span>
<span id="cb1-127"><a href="#cb1-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-128"><a href="#cb1-128" aria-hidden="true" tabindex="-1"></a>: **Table 1.1** Summary table of statistical learning methods</span>
<span id="cb1-129"><a href="#cb1-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-130"><a href="#cb1-130" aria-hidden="true" tabindex="-1"></a><span class="fu">## Assessing Model Accuracy</span></span>
<span id="cb1-131"><a href="#cb1-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-132"><a href="#cb1-132" aria-hidden="true" tabindex="-1"></a>A fundamental question in statistical learning can be expressed as a: *how do we know which method or model is the best one to use for a given dataset?* This might seem like a simple question at first, but it is actually one of the most challenging aspects of statistical learning in practice.</span>
<span id="cb1-133"><a href="#cb1-133" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-134"><a href="#cb1-134" aria-hidden="true" tabindex="-1"></a>When we build a statistical learning model, we need a way to evaluate how well it actually works. In other words, we need to measure how close the model's predictions are to the real values we observe in the data. This is what we mean by **measuring the quality of fit**. Without such a measure, we would have no principled way of comparing different models or deciding whether a particular approach is adequate for our research question.</span>
<span id="cb1-135"><a href="#cb1-135" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-136"><a href="#cb1-136" aria-hidden="true" tabindex="-1"></a><span class="fu">### The regression setting</span></span>
<span id="cb1-137"><a href="#cb1-137" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-138"><a href="#cb1-138" aria-hidden="true" tabindex="-1"></a>In the regression setting, where the response variable is quantitative, the most commonly used measure of fit is the **mean squared error** (MSE). The mean squared error is calculated by taking each observation in the dataset, computing the difference between the actual observed value and the value that the model predicts, squaring that difference, and then averaging all of these squared differences across every observation. Formally, MSE is expressed as:</span>
<span id="cb1-139"><a href="#cb1-139" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-140"><a href="#cb1-140" aria-hidden="true" tabindex="-1"></a>$MSE = \frac{1}{n} \times \sum_{i=1}^n(y_i - \hat{f}(x_i))^2$</span>
<span id="cb1-141"><a href="#cb1-141" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-142"><a href="#cb1-142" aria-hidden="true" tabindex="-1"></a>The logic behind this measure is straightforward. If our model's predictions are very close to the true observed values, the differences will be small, the squared differences will be even smaller, and the average of all those squared differences will be a small number. On the other hand, if the model produces predictions that are far from the actual values for at least some observations, the squared differences will be large, pulling the MSE upward. Squaring the differences serves two purposes: it ensures that positive and negative errors do not cancel each other out, and it penalizes larger errors more heavily than smaller ones.</span>
<span id="cb1-143"><a href="#cb1-143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-144"><a href="#cb1-144" aria-hidden="true" tabindex="-1"></a>To make this concrete, consider our example of predicting adult income. Suppose the researcher has collected data on a sample of one thousand individuals, recording each person's educational credentials, occupation, region, parents' socioeconomic status, race, gender, and years of work experience, along with their actual adult income. The researcher then estimates the function $f$ using some statistical learning method - perhaps a linear regression model - to produce a predicted income $\hat{f}(x_i)$ for each person in the dataset. For one individual, the model might predict an annual income of 38,000 euros while the person actually earns 42,000 euros, yielding a difference of 4,000 euros. For another individual, the model might predict 55,000 euros while the person earns 53,000 euros, giving a difference of 2,000 euros. The mean squared error takes all of these individual discrepancies, squares each one, and averages them across the entire sample. The resulting number gives us a single summary of how well the model's predictions match reality.</span>
<span id="cb1-145"><a href="#cb1-145" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-146"><a href="#cb1-146" aria-hidden="true" tabindex="-1"></a>The MSE we just described is computed using the same data that were used to build the model. This is called the **training MSE**, because it measures how well the model fits the training data - the observations the model has already seen and learned from. At first glance, it might seem perfectly reasonable to use the training MSE to evaluate a model. After all, if a model fits the data well, that should mean it is a good model. However, this reasoning is flawed. In most practical situations, we do not actually care how well the model fits the data it was trained on. What we really care about is how well the model will perform on new data that it has never seen before. This new, unseen data is called test data, and the MSE computed on test data is called the **test MSE**.</span>
<span id="cb1-147"><a href="#cb1-147" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-148"><a href="#cb1-148" aria-hidden="true" tabindex="-1"></a>To understand why this distinction matters so profoundly, let us return to our income inequality example. Suppose the researcher has built a model using data from a survey conducted in 2018, which includes information on one thousand individuals and their incomes. The model fits these one thousand observations well, producing a low training MSE. But the real purpose of the model is not to predict the incomes of these specific one thousand people whose incomes the researcher already knows. The real purpose is to predict incomes for new individuals - perhaps people surveyed in 2020, or individuals from a different but comparable population - based on their educational credentials, occupation, region, family background, race, gender, and work experience. The question that truly matters is whether the model will produce accurate predictions for these new cases, not whether it accurately reproduces the incomes of the people it was trained on.</span>
<span id="cb1-149"><a href="#cb1-149" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-150"><a href="#cb1-150" aria-hidden="true" tabindex="-1"></a>This is the fundamental insight: the training MSE measures something that is not of primary interest, while the test MSE measures something that is. A model that performs beautifully on its training data might perform poorly on new data, and a model with a somewhat higher training MSE might actually generalize better to unseen observations.</span>
<span id="cb1-151"><a href="#cb1-151" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-152"><a href="#cb1-152" aria-hidden="true" tabindex="-1"></a>Many statistical learning methods are designed, either directly or indirectly, to minimize the training MSE. They adjust their estimates and coefficients specifically to fit the training observations as closely as possible. As a result, the training MSE can be driven very low - sometimes all the way to zero - but this does not mean that the model has learned the true underlying patterns in the data. Instead, the model may have started to learn the noise in the training data, the random fluctuations and idiosyncratic features that are specific to that particular sample and will not appear again in new data. In our income example, imagine that the researcher uses a highly flexible model that can adapt to very fine details in the data. This model might learn that in the specific 2018 sample, there was one individual from a particular small region who had low education but unusually high income, perhaps due to an inheritance or a lucky business venture. A very flexible model might adjust its predictions to accommodate this particular case, effectively learning the specific circumstances of this one person rather than the general relationship between education and income. When the model is then applied to new individuals, this kind of overly specific learning will not help and may actually hurt prediction accuracy, because the idiosyncratic patterns of the training data do not generalize to the broader population.</span>
<span id="cb1-153"><a href="#cb1-153" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-154"><a href="#cb1-154" aria-hidden="true" tabindex="-1"></a>The chapter illustrates this problem using the concept of model flexibility. A model's flexibility refers to how closely it can conform to the patterns in the training data. At one end of the spectrum, a simple linear regression is relatively inflexible - it fits a straight line (or a flat hyperplane in multiple dimensions) through the data. At the other end, highly flexible methods like smoothing splines or very complex nonlinear models can bend and curve to follow almost every individual data point. The key finding, which the chapter demonstrates through several examples, is that as model flexibility increases, the training MSE will always decrease - because a more flexible model can always conform more closely to the training data. However, the test MSE does not simply decrease along with the training MSE. Instead, the test MSE initially decreases as the model becomes flexible enough to capture the real underlying patterns, but at some point it reaches a minimum and then begins to increase again. This produces the characteristic U-shaped curve that appears throughout the book.</span>
<span id="cb1-155"><a href="#cb1-155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-156"><a href="#cb1-156" aria-hidden="true" tabindex="-1"></a>In the income inequality context, a linear regression model assumes that the relationship between each predictor and income is a straight line. This might miss important nonlinearities - for example, the return to education might increase sharply once a person obtains a university degree, rather than rising smoothly with each additional year of schooling. A somewhat more flexible model could capture this nonlinearity and would likely produce better predictions on new data, yielding a lower test MSE. However, if the researcher keeps increasing flexibility - allowing the model to capture finer and finer details of the training data - at some point the model starts picking up noise rather than signal. It might learn that in this particular sample, people with exactly fourteen years of education and exactly eight years of work experience who live in one specific region have unusually high incomes, when in reality this pattern is just a coincidence in the sample. At this point, the test MSE starts rising again, even as the training MSE continues to fall.</span>
<span id="cb1-157"><a href="#cb1-157" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-158"><a href="#cb1-158" aria-hidden="true" tabindex="-1"></a>The phenomenon, where a model fits the training data too closely and as a result performs poorly on new data, is called **overfitting**. It occurs when a statistical learning method works too hard to find patterns in the training data and ends up capturing patterns that are caused by random chance rather than by genuine features of the underlying relationship. When overfitting occurs, the training MSE is very low but the test MSE is high, because the spurious patterns the model learned from the training data do not exist in the test data.</span>
<span id="cb1-159"><a href="#cb1-159" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-160"><a href="#cb1-160" aria-hidden="true" tabindex="-1"></a>To understand overfitting in our example, think of it this way. The true relationship between the seven predictors and adult income has a certain level of complexity. Education, occupation, region, family background, race, gender, and work experience all influence income in systematic ways, but those systematic influences operate at a general level - they describe broad patterns that hold across many individuals. A good model captures these broad, stable patterns. An overfit model goes beyond these patterns and starts memorizing the specific incomes of specific individuals in the training sample, including all the random variation that makes each person's income slightly different from what the general pattern would predict. Since this random variation is specific to the training sample and will not replicate in new data, the overfit model ends up making worse predictions when applied to new observations.</span>
<span id="cb1-161"><a href="#cb1-161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-162"><a href="#cb1-162" aria-hidden="true" tabindex="-1"></a>Regardless of whether overfitting has occurred, the training MSE will almost always be smaller than the test MSE. This is simply because most methods are designed to minimize the training MSE, so they will naturally fit the training data better than any data they have not seen. Overfitting refers specifically to the situation where additional flexibility leads to a worse test MSE - that is, where a less flexible model would actually have produced better predictions on new data.</span>
<span id="cb1-163"><a href="#cb1-163" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-164"><a href="#cb1-164" aria-hidden="true" tabindex="-1"></a>In practice, the researcher can usually compute the training MSE quite easily, since it only requires the data used to fit the model. However, estimating the test MSE is considerably more difficult because test data may not be available. If the researcher studying income inequality has only one dataset, there is no separate pool of unseen observations on which to evaluate the model. One important solution to this problem is **cross-validation** which provides a way to estimate the test MSE using only the training data by cleverly splitting the data into parts and alternating which part serves as the training set and which serves as the test set. This allows the researcher to approximate how well the model would perform on genuinely new data without actually needing a separate test dataset.</span>
<span id="cb1-165"><a href="#cb1-165" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-166"><a href="#cb1-166" aria-hidden="true" tabindex="-1"></a>Summarizing the above, evaluating a model's quality requires looking beyond how well it fits the data it was trained on. The true measure of a model's value is its ability to make accurate predictions for observations it has never encountered. This principle applies whether we are predicting any phenomenon in the social sciences. Understanding the distinction between training performance and test performance, and recognizing the danger of overfitting, are essential foundations for the study of statistical learning.</span>
<span id="cb1-167"><a href="#cb1-167" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-168"><a href="#cb1-168" aria-hidden="true" tabindex="-1"></a><span class="fu">#### The Bias-Variance Trade-Off</span></span>
<span id="cb1-169"><a href="#cb1-169" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-170"><a href="#cb1-170" aria-hidden="true" tabindex="-1"></a>In the previous section, we established that when we evaluate a statistical learning model, what truly matters is the test MSE - how well the model predicts outcomes for new, previously unseen observations. We also observed that as model flexibility increases, the test MSE tends to follow a characteristic U-shape: it initially decreases, reaches a minimum at some optimal level of flexibility, and then begins to increase again. The bias-variance trade-off is the theoretical explanation for why this U-shape occurs. It is one of the most important concepts in all of statistical learning, and understanding it deeply will help us make better decisions about which models to use and how flexible those models should be.</span>
<span id="cb1-171"><a href="#cb1-171" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-172"><a href="#cb1-172" aria-hidden="true" tabindex="-1"></a>Expected test MSE at any given point can always be broken down into the sum of three distinct quantities:</span>
<span id="cb1-173"><a href="#cb1-173" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-174"><a href="#cb1-174" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>the variance of the model's prediction,</span>
<span id="cb1-175"><a href="#cb1-175" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-176"><a href="#cb1-176" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>the squared bias of the model's prediction, and</span>
<span id="cb1-177"><a href="#cb1-177" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-178"><a href="#cb1-178" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>the variance of the irreducible error.</span>
<span id="cb1-179"><a href="#cb1-179" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-180"><a href="#cb1-180" aria-hidden="true" tabindex="-1"></a>This decomposition is expressed formally as:</span>
<span id="cb1-181"><a href="#cb1-181" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-182"><a href="#cb1-182" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-183"><a href="#cb1-183" aria-hidden="true" tabindex="-1"></a>E(y_0 - \hat{f}(x_0))^2 = Var(\hat{f}(x_0)) + <span class="co">[</span><span class="ot">Bias(\hat{f}(x_0))</span><span class="co">]</span>^2 + Var(\epsilon)</span>
<span id="cb1-184"><a href="#cb1-184" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-185"><a href="#cb1-185" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-186"><a href="#cb1-186" aria-hidden="true" tabindex="-1"></a>The term on the left side of this equation is the expected test MSE at a particular point $x_0$​. The word "expected" here has a specific meaning: it refers to the average test MSE we would obtain if we were to repeat the entire process of collecting training data and fitting the model many times over. Each time we collect a new training dataset and fit a model, we would get a slightly different estimate $\hat{f}$, and therefore a slightly different prediction error at $x_0$​. The expected test MSE is the average of all these prediction errors across all possible training datasets we might have drawn. This decomposition tells us something profound. It says that the prediction error at any point is not a single monolithic quantity but rather the sum of three fundamentally different sources of error. To build good models, we need to understand each of these three components and how they relate to each other.</span>
<span id="cb1-187"><a href="#cb1-187" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-188"><a href="#cb1-188" aria-hidden="true" tabindex="-1"></a>**1. Understanding Variance**</span>
<span id="cb1-189"><a href="#cb1-189" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-190"><a href="#cb1-190" aria-hidden="true" tabindex="-1"></a>The first component is the variance of $\hat{f}(x_0)$. Variance, in this context, refers to how much the model's prediction at the point $x_0$​ would change if we estimated the model using a different training dataset. Remember that the training data are a sample drawn from a larger population, and if we were to draw a different sample, we would get different data points and therefore a different estimated function $\hat{f}$​. If a method has high variance, it means that small changes in the training data lead to large changes in the estimated function and therefore in the predictions the model produces. If a method has low variance, the predictions remain relatively stable regardless of which particular training dataset is used.</span>
<span id="cb1-191"><a href="#cb1-191" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-192"><a href="#cb1-192" aria-hidden="true" tabindex="-1"></a>To understand this in the context of our income inequality example, imagine that the researcher conducts the same study multiple times, each time drawing a new random sample of one thousand individuals from the population. Each sample will contain slightly different people with slightly different combinations of education, occupation, region, family background, race, gender, work experience, and income. Now suppose the researcher fits the same type of model to each of these different samples. If the method has low variance, the predicted income for a person with, say, a university degree, a professional occupation, living in an urban area, from a middle-class family, who is a white male with ten years of work experience would be roughly similar regardless of which particular sample the model was trained on. The predictions would be stable and consistent across different training datasets. However, if the method has high variance, the predicted income for this same hypothetical person could change dramatically depending on which sample happened to be drawn. One sample might produce a prediction of 45,000 euros while another sample, drawn from the same population, might produce a prediction of 52,000 euros, and yet another might yield 39,000 euros. This instability in predictions is what we mean by high variance.</span>
<span id="cb1-193"><a href="#cb1-193" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-194"><a href="#cb1-194" aria-hidden="true" tabindex="-1"></a>The crucial insight is that more flexible methods tend to have higher variance. The reason is intuitive. A highly flexible model can conform closely to the specific patterns in whatever training data it receives. This means it is highly sensitive to the particular observations in the training set. If one influential individual is replaced by another, the flexible model might change its predictions substantially because it was fitting so closely to each data point. In our income example, a very flexible model might learn intricate patterns specific to the particular one thousand people in the sample - perhaps noticing that in this specific dataset, people from a certain small region with a certain combination of education and experience earn unusually high incomes. If a different sample were drawn, this particular pattern would likely not reappear, and the model's predictions would shift accordingly.</span>
<span id="cb1-195"><a href="#cb1-195" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-196"><a href="#cb1-196" aria-hidden="true" tabindex="-1"></a>In contrast, a simple linear regression model has low variance because it is constrained to fit a straight-line relationship. Changing a few observations in the training data will only shift the line slightly. The predictions are stable because the model's rigid structure prevents it from responding dramatically to the idiosyncrasies of any particular sample. Whether the researcher uses sample A or sample B, a linear model will produce roughly similar predictions, because it can only capture broad, linear trends that tend to be consistent across samples.</span>
<span id="cb1-197"><a href="#cb1-197" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-198"><a href="#cb1-198" aria-hidden="true" tabindex="-1"></a>**2. Understanding Bias**</span>
<span id="cb1-199"><a href="#cb1-199" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-200"><a href="#cb1-200" aria-hidden="true" tabindex="-1"></a>The second component of the expected test MSE is the squared bias of $\hat{f}(x_0)$. Bias refers to the error that arises from approximating a real-world phenomenon, which may be very complex, with a simplified model. It measures the difference between the average prediction of our model (averaged over all possible training datasets) and the true value of the function $f$ at the point $x_0$​. In other words, bias captures how far off our model is, on average, from the truth - not because of random fluctuations in the training data, but because the model itself is structurally incapable of capturing the true relationship.</span>
<span id="cb1-201"><a href="#cb1-201" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-202"><a href="#cb1-202" aria-hidden="true" tabindex="-1"></a>Returning to the income inequality example, suppose that the true relationship between the seven predictors and adult income is genuinely complex. Perhaps the return to education is nonlinear, with relatively modest income gains for each additional year of schooling at lower levels but a sharp jump when a person completes a university degree. Perhaps there are important interactions between predictors - for instance, the effect of work experience on income might differ substantially depending on occupation, with experience mattering a great deal in some professions and very little in others. Perhaps the relationship between parental socioeconomic status and adult income is mediated in complex ways by education and region, creating patterns that cannot be captured by a simple additive model.</span>
<span id="cb1-203"><a href="#cb1-203" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-204"><a href="#cb1-204" aria-hidden="true" tabindex="-1"></a>If the researcher uses a simple linear regression to model this complex reality, the model assumes that each predictor has a constant, additive effect on income. It cannot capture the sharp jump at university degree completion, it cannot represent the interaction between experience and occupation, and it cannot model the complex mediating role of family background. No matter how much training data the researcher collects, the linear model will systematically miss these features of the true relationship. This systematic error is bias. The model is biased because its structure is too simple to represent the truth. Even if the researcher could average the predictions across infinitely many training samples, the average prediction of the linear model would still differ from the true $f$ because the model is fundamentally incapable of representing the true relationship.</span>
<span id="cb1-205"><a href="#cb1-205" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-206"><a href="#cb1-206" aria-hidden="true" tabindex="-1"></a>More flexible methods tend to have lower bias because they can adapt to a wider range of possible shapes for $f$. A flexible model that allows for nonlinear effects and interactions would be better able to capture the true complexity of how education, occupation, family background, and other factors jointly determine income. If the model's structure is rich enough, it can, in principle, approximate the true function $f$ very closely, resulting in low or even negligible bias.</span>
<span id="cb1-207"><a href="#cb1-207" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-208"><a href="#cb1-208" aria-hidden="true" tabindex="-1"></a>The reason this concept is called a **trade-off** is that bias and variance tend to move in opposite directions as model flexibility changes. Simple, inflexible methods like linear regression have high bias because they impose strong assumptions about the form of $f$ that may not be accurate. But they have low variance because their rigid structure makes them resistant to fluctuations in the training data. Flexible methods, on the other hand, have low bias because they can adapt to complex patterns in the data, but they have high variance because they are sensitive to the specific observations in the training set.</span>
<span id="cb1-209"><a href="#cb1-209" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-210"><a href="#cb1-210" aria-hidden="true" tabindex="-1"></a>The expected test MSE is the sum of variance, squared bias, and the irreducible error. The irreducible error, $Var(\epsilon)$, is a constant that does not depend on the model at all - it represents the inherent unpredictability in the response that no model, no matter how sophisticated, can eliminate. In our income example, the irreducible error encompasses all the factors that influence income but are not captured by the seven predictors: individual personality traits, chance events, unmeasured forms of discrimination, health shocks, and countless other sources of variation. Since the irreducible error is fixed, the test MSE can only be reduced by managing the other two components: variance and bias.</span>
<span id="cb1-211"><a href="#cb1-211" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-212"><a href="#cb1-212" aria-hidden="true" tabindex="-1"></a>As we increase flexibility, bias decreases. The model becomes better able to capture the true patterns in the data, and the systematic error introduced by an overly simplistic model structure diminishes. At the same time, variance increases. The model becomes more sensitive to the particular training data, and its predictions become less stable across different samples. The test MSE depends on the combined effect of these two opposing forces.</span>
<span id="cb1-213"><a href="#cb1-213" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-214"><a href="#cb1-214" aria-hidden="true" tabindex="-1"></a>At low levels of flexibility, the model has high bias and low variance. The bias dominates the test MSE, and increasing flexibility helps because the reduction in bias is larger than the increase in variance. This is why the test MSE initially decreases as flexibility grows. In our income example, moving from a very rigid model - say, one that predicts the same average income for everyone regardless of their characteristics - to a basic linear regression would substantially reduce bias by allowing the model to capture at least the broad linear relationships between predictors and income. The test MSE would drop considerably because the improvement from lower bias far outweighs the modest increase in variance.</span>
<span id="cb1-215"><a href="#cb1-215" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-216"><a href="#cb1-216" aria-hidden="true" tabindex="-1"></a>At moderate levels of flexibility, the model has found a good balance. It is flexible enough to capture the important patterns in the data but not so flexible that it is chasing noise. This is the point where the test MSE reaches its minimum, representing the best achievable predictive performance for the given set of predictors and the given type of model.</span>
<span id="cb1-217"><a href="#cb1-217" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-218"><a href="#cb1-218" aria-hidden="true" tabindex="-1"></a>At high levels of flexibility, something changes. The bias has already been reduced to a low level, so further increases in flexibility yield only marginal improvements in bias. But variance continues to climb as the model becomes increasingly sensitive to the training data. Now the increase in variance outweighs the decrease in bias, and the test MSE begins to rise. The model is overfitting - it has become so flexible that it is learning noise rather than signal, and its predictions on new data suffer as a result.</span>
<span id="cb1-219"><a href="#cb1-219" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-220"><a href="#cb1-220" aria-hidden="true" tabindex="-1"></a>This is why the test MSE exhibits the U-shape we discussed earlier. The left side of the U corresponds to high-bias, low-variance models that are too simple. The right side corresponds to low-bias, high-variance models that are too complex. The bottom of the U is the sweet spot where bias and variance are optimally balanced.</span>
<span id="cb1-221"><a href="#cb1-221" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-222"><a href="#cb1-222" aria-hidden="true" tabindex="-1"></a>Let us trace through this trade-off more concretely using the income inequality study. Suppose the researcher considers a range of models of increasing flexibility. At the simplest extreme, imagine a model that simply predicts the overall average income in the training sample for every individual, regardless of their education, occupation, or any other characteristic. This model has essentially zero variance - it will produce nearly the same prediction no matter which training sample is drawn, because sample means are very stable. But it has enormous bias, because it completely ignores all the systematic relationships between the predictors and income. The test MSE would be very high, driven almost entirely by bias. Next, consider a standard linear regression that includes all seven predictors. This model can capture the average linear effect of education, occupation, region, family background, race, gender, and work experience on income. Compared to the naive average, it has substantially lower bias because it acknowledges that these factors matter and estimates their effects. Its variance is still relatively low because the linear structure constrains the model considerably. The test MSE would be much lower than that of the naive model. Now consider a more flexible model that allows for nonlinear effects - perhaps using polynomial terms or splines to model the relationship between years of education and income, or including interaction terms that allow the effect of work experience to vary by occupation. This model can capture important features of the true relationship that linear regression misses, such as the disproportionate returns to completing a university degree or the different career trajectories across occupations. The bias decreases further. The variance increases somewhat because the model now has more parameters to estimate and is more sensitive to the particular sample. If the true relationship genuinely contains these nonlinearities and interactions, the reduction in bias will outweigh the increase in variance, and the test MSE will decrease. However, if the researcher continues to increase flexibility - adding higher-order polynomial terms, three-way and four-way interactions between predictors, and extremely localized fits - the model begins to adapt to features of the training data that are not part of the true underlying relationship. Perhaps in this specific sample, there happen to be three individuals from a particular region who all have unusually high incomes, and the very flexible model adjusts its predictions for that region upward to accommodate these three people. In a new sample, this pattern would not recur, and the model's predictions for that region would be systematically too high. The variance is now large, the bias gains from additional flexibility are negligible, and the test MSE starts climbing.</span>
<span id="cb1-223"><a href="#cb1-223" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-224"><a href="#cb1-224" aria-hidden="true" tabindex="-1"></a>**3. The Irreducible Error as a Floor**</span>
<span id="cb1-225"><a href="#cb1-225" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-226"><a href="#cb1-226" aria-hidden="true" tabindex="-1"></a>An important implication of the bias-variance decomposition is that there is a floor below which the test MSE can never fall, no matter how good our model is. This floor is the irreducible error, $Var(\epsilon)$. In the income inequality example, even if we had a perfect model that captured every systematic relationship between the seven predictors and income, there would still be variation in income that these predictors cannot explain. Two individuals who are identical in terms of education, occupation, region, family background, race, gender, and work experience will still have different incomes, because of all the unmeasured factors that influence earnings. No model built from these seven predictors can predict this residual variation, and so the test MSE can never be reduced below this level.</span>
<span id="cb1-227"><a href="#cb1-227" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-228"><a href="#cb1-228" aria-hidden="true" tabindex="-1"></a>This is an important reminder for social science researchers. The irreducible error is not a failure of the model - it is a reflection of the inherent complexity of social phenomena. Human income is influenced by a vast number of factors, and no finite set of predictors can account for all of them. The goal of statistical learning is not to eliminate all prediction error but to reduce the reducible portion of the error - the part driven by bias and variance - as much as possible.</span>
<span id="cb1-229"><a href="#cb1-229" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-230"><a href="#cb1-230" aria-hidden="true" tabindex="-1"></a>The bias-variance trade-off has profound practical implications for anyone building statistical models in the social sciences. It tells us that the most complex model is not necessarily the best model. A researcher who uses an extremely flexible machine learning method to predict income might achieve a very low training MSE, but if the model has high variance, its predictions on new data could be poor. Conversely, a researcher who sticks with simple linear regression out of tradition might be leaving predictive accuracy on the table if the true relationships are genuinely nonlinear. The trade-off also explains why different datasets may require different levels of model flexibility. If the true relationship between predictors and the response is approximately linear - perhaps because the predictors have been carefully chosen and transformed - then a simple model will have low bias to begin with, and increasing flexibility will mainly add variance without much benefit. If, on the other hand, the true relationship is highly nonlinear and involves complex interactions, a simple model will have high bias, and the researcher needs to use a more flexible approach to capture the important patterns, accepting some increase in variance as the cost of reducing bias.</span>
<span id="cb1-231"><a href="#cb1-231" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-232"><a href="#cb1-232" aria-hidden="true" tabindex="-1"></a>In real-life situations where the true $f$ is unknown - which is essentially always the case in practice - we cannot directly compute the bias, the variance, or even the test MSE. We cannot look at the decomposition and decide exactly where the optimal flexibility lies. Nevertheless, keeping the bias-variance trade-off in mind helps guide our thinking. It reminds us to be skeptical of models that fit the training data too perfectly, to consider whether our model might be too simple or too complex for the phenomenon at hand, and to use techniques like cross-validation to empirically estimate the test MSE and find a good balance between bias and variance.</span>
<span id="cb1-233"><a href="#cb1-233" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-234"><a href="#cb1-234" aria-hidden="true" tabindex="-1"></a><span class="fu">### The Classification Setting</span></span>
<span id="cb1-235"><a href="#cb1-235" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-236"><a href="#cb1-236" aria-hidden="true" tabindex="-1"></a>Up to this point, our discussion of model accuracy has focused entirely on the regression setting, where the response variable is quantitative. However, many research questions in the social sciences involve response variables that are qualitative rather than quantitative. A qualitative response variable takes on values that represent discrete categories or classes rather than numerical quantities. The classification setting deals with precisely this kind of problem: predicting which category an observation belongs to, rather than predicting a numerical value.</span>
<span id="cb1-237"><a href="#cb1-237" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-238"><a href="#cb1-238" aria-hidden="true" tabindex="-1"></a>The concepts we have already covered - the distinction between training and test performance, the danger of overfitting, and the bias-variance trade-off - all carry over to the classification setting. However, the specific measures we use to evaluate model performance need to be adapted, because it no longer makes sense to talk about squared differences between predicted and actual values when the response is a category rather than a number.</span>
<span id="cb1-239"><a href="#cb1-239" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-240"><a href="#cb1-240" aria-hidden="true" tabindex="-1"></a>To make the classification setting concrete within our sociological example, let us modify the research question slightly. Instead of predicting how much a person earns, suppose the researcher is now interested in predicting whether a person will end up in a state of economic vulnerability or not. The researcher might define economic vulnerability as earning below a certain threshold - say, below 60 percent of the median national income, which is a commonly used measure of relative poverty risk in European social policy research. The response variable Y is now qualitative: for each individual, it takes one of two values, either "economically vulnerable" or "not economically vulnerable". The predictors remain the same seven variables we have been working with: educational credentials ($X_1$​), occupation ($X_2$​), geographic region ($X_3$​), parents' socioeconomic status ($X_4$), race ($X_5$​), gender ($X_6$​), and years of work experience ($X_7$​). The research question is no longer about predicting the exact income a person will earn, but about classifying each individual into one of two categories based on their characteristics. This is a classification problem, and it requires different tools for measuring how well our model performs.</span>
<span id="cb1-241"><a href="#cb1-241" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-242"><a href="#cb1-242" aria-hidden="true" tabindex="-1"></a>In the regression setting, we measured model performance using the mean squared error, which quantifies how far the predicted numerical values are from the actual numerical values. In the classification setting, the natural analogue is the **error rate**, which simply measures the proportion of observations that are incorrectly classified. The training error rate is computed by applying the model to the training data and counting the fraction of cases where the predicted class does not match the true class. Formally, this is expressed as:</span>
<span id="cb1-243"><a href="#cb1-243" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-244"><a href="#cb1-244" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-245"><a href="#cb1-245" aria-hidden="true" tabindex="-1"></a>\frac{1}{n} \sum_{i=1}^{n} I(y_i \neq \hat{y}_i)</span>
<span id="cb1-246"><a href="#cb1-246" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-247"><a href="#cb1-247" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-248"><a href="#cb1-248" aria-hidden="true" tabindex="-1"></a>In this formula, $\hat{y}_i$​ is the class label that the model predicts for the $i$-th observation, and $I(y_i \neq \hat{y}_i)$ is an indicator function that equals one whenever the prediction is wrong and zero whenever the prediction is correct. By summing these indicators across all observations and dividing by the total number of observations, we get the fraction of misclassifications - the training error rate.</span>
<span id="cb1-249"><a href="#cb1-249" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-250"><a href="#cb1-250" aria-hidden="true" tabindex="-1"></a>In our example, suppose the researcher trains a classification model on data from one thousand individuals. The model predicts, for each person, whether they are economically vulnerable or not. If the model correctly classifies 920 of the 1,000 individuals and misclassifies 80, the training error rate is 80 divided by 1,000, which equals 0.08, or 8 percent. This means the model gets it wrong for 8 percent of the people in the training sample.</span>
<span id="cb1-251"><a href="#cb1-251" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-252"><a href="#cb1-252" aria-hidden="true" tabindex="-1"></a>However, just as in the regression setting, the training error rate is not what we truly care about. What matters is the test error rate - the proportion of misclassifications when the model is applied to new observations that were not part of the training data. The test error rate is given by:</span>
<span id="cb1-253"><a href="#cb1-253" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-254"><a href="#cb1-254" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-255"><a href="#cb1-255" aria-hidden="true" tabindex="-1"></a>Ave(I(y_0 \neq \hat{y}_0))</span>
<span id="cb1-256"><a href="#cb1-256" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-257"><a href="#cb1-257" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-258"><a href="#cb1-258" aria-hidden="true" tabindex="-1"></a>This measures the average misclassification rate across test observations. A good classifier is one that achieves the smallest possible test error rate, meaning it correctly classifies the highest proportion of new, unseen individuals.</span>
<span id="cb1-259"><a href="#cb1-259" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-260"><a href="#cb1-260" aria-hidden="true" tabindex="-1"></a>In our context, the researcher wants a model that can accurately predict economic vulnerability for future individuals - people who were not in the original training sample. Perhaps the model will be used to identify individuals at risk of poverty in a new survey wave, or to target social policy interventions toward those most likely to be economically vulnerable. The value of the model lies not in how well it classifies the one thousand people whose outcomes are already known, but in how well it classifies new individuals whose outcomes the researcher does not yet know.</span>
<span id="cb1-261"><a href="#cb1-261" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-262"><a href="#cb1-262" aria-hidden="true" tabindex="-1"></a><span class="fu">#### The Bayes Classifier</span></span>
<span id="cb1-263"><a href="#cb1-263" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-264"><a href="#cb1-264" aria-hidden="true" tabindex="-1"></a>The **Bayes classifier** represents the best possible classification rule - the one that produces the lowest possible test error rate. Understanding the Bayes classifier is important not because we can ever actually use it in practice, but because it provides a benchmark against which all real classification methods can be evaluated.</span>
<span id="cb1-265"><a href="#cb1-265" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-266"><a href="#cb1-266" aria-hidden="true" tabindex="-1"></a>The Bayes classifier works on a deceptively simple principle: for each observation, assign it to the class that is most probable given its predictor values. Formally, for a test observation with predictor vector $x_0$​, the Bayes classifier assigns the observation to the class $j$ for which the conditional probability $Pr(Y = j \mid X = x_0)$ is largest.</span>
<span id="cb1-267"><a href="#cb1-267" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-268"><a href="#cb1-268" aria-hidden="true" tabindex="-1"></a>To understand what this means in our example, consider a specific individual - a woman with a university degree, working in a service occupation, living in a rural region, from a lower-middle-class family background, who is white and has five years of work experience. The Bayes classifier asks: *given this particular combination of characteristics, what is the probability that this person is economically vulnerable, and what is the probability that she is not?* If the probability of being economically vulnerable given her specific profile is 0.25, and the probability of not being economically vulnerable is 0.75, then the Bayes classifier assigns her to the "not economically vulnerable" category, because that is the more probable outcome for someone with her characteristics.</span>
<span id="cb1-269"><a href="#cb1-269" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-270"><a href="#cb1-270" aria-hidden="true" tabindex="-1"></a>In a two-class problem like ours - where the response is either "economically vulnerable" or "not economically vulnerable" - the Bayes classifier reduces to a simple rule: classify the individual as economically vulnerable if the probability of economic vulnerability given their predictor values exceeds 0.5, and classify them as not economically vulnerable otherwise. The boundary in predictor space where the probability of each class is exactly equal — where $Pr(Y = vulnerable \mid X = x_0) = 0.5$ - is called the **Bayes decision boundary**. On one side of this boundary, individuals are classified as vulnerable; on the other side, they are classified as not vulnerable.</span>
<span id="cb1-271"><a href="#cb1-271" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-272"><a href="#cb1-272" aria-hidden="true" tabindex="-1"></a>The Bayes classifier produces the lowest possible test error rate, called the **Bayes error rate**. This rate is given by:</span>
<span id="cb1-273"><a href="#cb1-273" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-274"><a href="#cb1-274" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-275"><a href="#cb1-275" aria-hidden="true" tabindex="-1"></a>1 - E\left(\max_j \Pr(Y = j \mid X)\right)</span>
<span id="cb1-276"><a href="#cb1-276" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-277"><a href="#cb1-277" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-278"><a href="#cb1-278" aria-hidden="true" tabindex="-1"></a>The Bayes error rate is greater than zero whenever there is any overlap between the classes in the population - that is, whenever there exist regions of the predictor space where neither class has a probability of one. In our example, this overlap is substantial. Even among people with very similar educational credentials, occupations, and family backgrounds, some will be economically vulnerable and others will not, because of all the unmeasured factors that influence income. No classifier, no matter how sophisticated, can perfectly separate the two groups based on the seven predictors alone. The Bayes error rate represents this fundamental limit on classification accuracy, and it is directly analogous to the irreducible error in the regression setting.</span>
<span id="cb1-279"><a href="#cb1-279" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-280"><a href="#cb1-280" aria-hidden="true" tabindex="-1"></a>The reason the Bayes classifier cannot be used in practice is that it requires perfect knowledge of the conditional probabilities $Pr(Y = j \mid X = x_0)$ for every possible combination of predictor values. In the real world, we never know these probabilities. We only have sample data from which we can try to estimate these probabilities. The Bayes classifier therefore serves as a theoretical gold standard - an ideal that real methods try to approximate but can never fully achieve.</span>
<span id="cb1-281"><a href="#cb1-281" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-282"><a href="#cb1-282" aria-hidden="true" tabindex="-1"></a><span class="fu">#### K-Nearest Neighbors</span></span>
<span id="cb1-283"><a href="#cb1-283" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-284"><a href="#cb1-284" aria-hidden="true" tabindex="-1"></a>Since the Bayes classifier is unattainable in practice, we need real methods that can approximate it using available data. One such method is the **K-nearest neighbors classifier**, commonly abbreviated as KNN. The KNN classifier is a conceptually simple approach that directly attempts to estimate the conditional probabilities that the Bayes classifier relies on, and then classifies each observation to the class with the highest estimated probability.</span>
<span id="cb1-285"><a href="#cb1-285" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-286"><a href="#cb1-286" aria-hidden="true" tabindex="-1"></a>The KNN classifier works as follows. Given a positive integer K and a new observation $x_0$​ that we want to classify, the algorithm first identifies the K training observations that are closest to $x_0$​ in the predictor space. This set of K nearest neighbors is denoted $\mathcal{N}_0$​. The classifier then estimates the conditional probability for each class as the proportion of those K neighbors that belong to that class:</span>
<span id="cb1-287"><a href="#cb1-287" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-288"><a href="#cb1-288" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-289"><a href="#cb1-289" aria-hidden="true" tabindex="-1"></a>\Pr(Y = j \mid X = x_0) = \frac{1}{K} \sum_{i \in \mathcal{N}_0} I(y_i = j)</span>
<span id="cb1-290"><a href="#cb1-290" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-291"><a href="#cb1-291" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-292"><a href="#cb1-292" aria-hidden="true" tabindex="-1"></a>Finally, KNN assigns the test observation $x_0$​ to the class with the largest estimated probability.</span>
<span id="cb1-293"><a href="#cb1-293" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-294"><a href="#cb1-294" aria-hidden="true" tabindex="-1"></a>To see how this works in our income inequality example, suppose the researcher wants to predict whether a new individual - let us call her Person A - is economically vulnerable or not. Person A has a specific set of characteristics: a vocational degree, a clerical occupation, living in a mid-sized city, from a working-class family, who is a white woman with three years of work experience. The KNN classifier, with, say, $K = 5$, would search through the entire training dataset of one thousand individuals and find the five people whose combination of education, occupation, region, family background, race, gender, and work experience is most similar to Person A's profile. Perhaps among these five nearest neighbors, three are not economically vulnerable and two are economically vulnerable. The estimated probability of being not vulnerable is then 3/5, or 0.6, and the estimated probability of being vulnerable is 2/5, or 0.4. Since 0.6 is greater than 0.5, KNN classifies Person A as not economically vulnerable.</span>
<span id="cb1-295"><a href="#cb1-295" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-296"><a href="#cb1-296" aria-hidden="true" tabindex="-1"></a>The intuition behind KNN is that people with similar characteristics tend to have similar outcomes. If most of the people in the training data who resemble Person A are not economically vulnerable, then it is reasonable to predict that Person A is also not economically vulnerable. This is a form of learning from analogy - the algorithm classifies new cases by looking at the outcomes of the most similar known cases.</span>
<span id="cb1-297"><a href="#cb1-297" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-298"><a href="#cb1-298" aria-hidden="true" tabindex="-1"></a>The value of K - the number of neighbors considered - is a crucial parameter that profoundly affects the behavior of the KNN classifier. The choice of K determines where the classifier falls on the flexibility spectrum and therefore directly influences the bias-variance trade-off. When K is very small, say $K = 1$, the classifier is extremely flexible. It classifies each new observation based on the single most similar training observation. This means the decision boundary - the line separating the region where the model predicts vulnerability from the region where it predicts non-vulnerability - is highly irregular, twisting and turning to accommodate the class label of every individual training observation. With $K = 1$, the training error rate is actually zero, because each training observation is its own nearest neighbor, so the model always correctly classifies every observation in the training set. However, this impressive training performance is misleading. The model has effectively memorized the training data, including all of its noise and idiosyncrasies. When applied to new data, many of these intricate local patterns will not hold up, and the test error rate will be considerably higher than zero.</span>
<span id="cb1-299"><a href="#cb1-299" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-300"><a href="#cb1-300" aria-hidden="true" tabindex="-1"></a>In our example, using $K = 1$ would mean that the classification of a new individual depends entirely on which single person in the training data happens to have the most similar profile. If that nearest neighbor happens to be an unusual case - perhaps someone who is economically vulnerable despite having relatively favorable characteristics, due to some unmeasured factor like a health crisis - the model would make an incorrect prediction. With $K = 1$, the classifier has very low bias because it imposes almost no assumptions about the shape of the true decision boundary, but it has very high variance because the prediction for any new observation can change dramatically depending on which particular training observations happen to be closest.</span>
<span id="cb1-301"><a href="#cb1-301" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-302"><a href="#cb1-302" aria-hidden="true" tabindex="-1"></a>When K is very large, the classifier becomes much less flexible. With a large K, the model averages over many training observations to make each prediction, which smooths out the local fluctuations and produces a decision boundary that is much more stable. However, if K is too large, the classifier becomes overly rigid. In the extreme case where K equals the total number of training observations, the classifier would simply predict the majority class for every new observation, ignoring the predictor values entirely. This would have very low variance - the prediction would be the same regardless of which training data were used - but very high bias, because it ignores all the information contained in the predictors.</span>
<span id="cb1-303"><a href="#cb1-303" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-304"><a href="#cb1-304" aria-hidden="true" tabindex="-1"></a>In our example, using a very large K, say $K = 100$, would mean that the prediction for each new individual is based on the outcomes of the 100 most similar people in the training data. This large neighborhood includes people who may not actually be very similar to the individual being classified, and the resulting prediction is essentially an average over a broad swath of the population. The decision boundary becomes very smooth, almost linear, and the model loses its ability to capture local patterns in the data - such as the fact that certain specific combinations of low education, unstable occupation, and disadvantaged family background are particularly strong predictors of economic vulnerability.</span>
<span id="cb1-305"><a href="#cb1-305" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-306"><a href="#cb1-306" aria-hidden="true" tabindex="-1"></a>Finall, neither extreme or very large K tends to produce good test error rates. With $K = 1$, the classifier overfits by being too responsive to individual data points. With very large K, the classifier underfits by being too insensitive to meaningful patterns. The best test performance is typically achieved at an intermediate value of K that balances the competing demands of bias and variance. In the simulated example presented in the chapter, $K = 10$ produced a test error rate very close to the theoretical minimum set by the Bayes error rate, illustrating that a well-chosen KNN classifier can approximate the unattainable Bayes classifier remarkably well.</span>
<span id="cb1-307"><a href="#cb1-307" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-308"><a href="#cb1-308" aria-hidden="true" tabindex="-1"></a>Just as in the regression setting, the test error rate in the classification setting follows the characteristic U-shape as model flexibility varies. For KNN, flexibility is inversely related to K: small values of K correspond to high flexibility, and large values of K correspond to low flexibility. To make the analogy with the regression plots clearer, the chapter plots the error rates as a function of $1/K$, so that moving to the right on the horizontal axis corresponds to increasing flexibility.</span>
<span id="cb1-309"><a href="#cb1-309" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-310"><a href="#cb1-310" aria-hidden="true" tabindex="-1"></a>As $1/K$ increases from near zero toward one - that is, as K decreases from very large values toward one - the training error rate steadily declines, eventually reaching zero at $K = 1$. This mirrors what we saw in the regression setting: more flexible models always fit the training data better. However, the test error rate does not follow the training error rate downward. Instead, it decreases initially as the classifier becomes flexible enough to capture the important patterns separating the two classes, reaches a minimum at some intermediate level of flexibility, and then increases as the classifier becomes so flexible that it starts overfitting to noise in the training data.</span>
<span id="cb1-311"><a href="#cb1-311" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-312"><a href="#cb1-312" aria-hidden="true" tabindex="-1"></a>In our economic vulnerability example, this means that the researcher would find that a moderately flexible KNN classifier - one that considers a reasonable number of neighbors rather than too few or too many - produces the most accurate predictions for new individuals. Using too few neighbors leads to erratic predictions driven by the particular circumstances of a handful of similar individuals in the training data. Using too many neighbors washes out the meaningful differences between people with different risk profiles, producing predictions that are too uniform.</span>
<span id="cb1-313"><a href="#cb1-313" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-314"><a href="#cb1-314" aria-hidden="true" tabindex="-1"></a>The classification setting reinforces the same fundamental lessons we learned in the regression setting. First, training performance is an unreliable guide to how well a model will perform on new data. A classifier that achieves a very low training error rate may be overfitting, memorizing the training data rather than learning generalizable patterns. Second, the bias-variance trade-off applies to classification just as it applies to regression. Simple classifiers have high bias and low variance, flexible classifiers have low bias and high variance, and the best test performance lies somewhere in between. Third, there exists a theoretical limit on how well any classifier can perform - the Bayes error rate - that is determined by the inherent overlap between the classes in the population and by the information content of the available predictors.</span>
<span id="cb1-315"><a href="#cb1-315" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-316"><a href="#cb1-316" aria-hidden="true" tabindex="-1"></a>For research on economic vulnerability, this means that no model built from the seven predictors we have considered can perfectly classify every individual. Some people with seemingly favorable characteristics will nonetheless be economically vulnerable, and some with seemingly unfavorable characteristics will not be. The irreducible error reflects the complexity of social life - the fact that economic outcomes are shaped by a multitude of factors, many of which cannot be captured in any feasible set of measured variables. The goal of the researcher is not to eliminate this irreducible uncertainty but to build a classifier that comes as close as possible to the Bayes ideal, capturing the genuine patterns in the data without being misled by noise.</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></div>
</div></div></div></div></div>
</div> <!-- /content -->




</body></html>