[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Statistical Learning in R for Social Sciences",
    "section": "",
    "text": "Preface\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "introduction_to_statistical_learning.html",
    "href": "introduction_to_statistical_learning.html",
    "title": "1  Introduction to Statistical Learning",
    "section": "",
    "text": "1.1 Statistical Learning Formula\nStatistical learning refers to a broad set of approaches and techniques for estimating the function that connects independent variables to an dependent variable. At its core, statistical learning is concerned with understanding the relationship between variables and using that understanding either to make predictions about future observations or to gain insight into how different factors influence an outcome.\nThe fundamental idea of statistical learning can be expressed through a simple formula:\n\\(Y = f(X) + \\epsilon\\)\nThis formula tells us that any outcome we wish to study or predict can be understood as the result of some systematic relationship between independent and dependent variables, plus some random variation that we cannot fully explain or control. The goal of statistical learning is to estimate the function \\(f\\) based on observed data, so that we can either predict Y for new observations or understand how changes in X are associated with changes in Y.\nLet’s now explain each component of this formula in detail.\nTo make these concepts concrete, let me illustrate them with the example. Consider a researcher studying income inequality and social mobility. The researcher might want to understand what determines a person’s income in adulthood. The dependent variable Y would be adult income, measured in monetary units. The predictors X might encompass the person’s own educational credentials, their occupation, the region where they live, their parents’ socioeconomic status, their race and gender, and the number of years of work experience they have accumulated. The function \\(f\\) would capture the systematic relationships between these characteristics and income, revealing how the labor market rewards different attributes and how social background continues to influence economic outcomes across generations. The error term \\(\\epsilon\\) would account for all the variation in income that these measured factors cannot explain. This residual variation might stem from unmeasured differences in job performance, luck in finding particularly good or bad employment matches, health shocks that affect earning capacity, or discrimination that varies in ways not captured by the measured variables.\nWe can write this relationship as: \\(Y\\ =\\ f(X_1,\\ X_2,\\ X_3,\\ X_4,\\ X_5,\\ X_6,\\ X_7)\\ +\\ ϵ\\)\nIn this formula, Y represents adult income measured in monetary units such as annual earnings in euros. This is the response we are trying to understand or predict. The predictors are defined as follows.\nThe function \\(f\\) captures the systematic relationship between all these predictors and adult income. This function describes how the labor market values different combinations of education, occupation, location, background, and demographic characteristics. The precise form of \\(f\\) is unknown to us and must be estimated from data. It might be relatively simple, such as a linear combination of the predictors, or it might be quite complex, involving interactions between variables and nonlinear relationships.\nThe error term \\(\\epsilon\\) represents all the variation in adult income that cannot be explained by the seven predictors we have included. This encompasses unmeasured factors such as individual differences in productivity, motivation, and interpersonal skills, as well as random events like fortunate or unfortunate timing in job searches, health events that affect earning capacity, and idiosyncratic experiences of discrimination or favoritism in the workplace, and so on.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to Statistical Learning</span>"
    ]
  },
  {
    "objectID": "introduction_to_statistical_learning.html#statistical-learning-formula",
    "href": "introduction_to_statistical_learning.html#statistical-learning-formula",
    "title": "1  Introduction to Statistical Learning",
    "section": "",
    "text": "The dependent variable or response, denoted by Y, represents the response that we are trying to understand, explain, or predict. This is the variable whose variation we want to account for using other available information. It is called dependent precisely because its values depend on, or are influenced by, other variables in the system we are studying.\nThe independent variable or predictor, denoted by X, represents the input information that we use to explain or predict the outcome. In most realistic situations, we have multiple predictors rather than just one, so X typically represents a collection of variables written as \\(X = (X_1, X_2, ..., X_p)\\), where \\(X_p\\) indicates the total number of predictors. The key characteristic of predictors is that they provide information that helps us understand or anticipate the values of the dependent variable.\nThe function \\(f\\) represents the systematic relationship between the dependent variable and the indipendent variable. This function captures all the information that the independent variables collectively provide about the dependent variable. In other words, \\(f\\) describes the pattern or rule that connects predictors to response in a consistent, reproducible way. The crucial point is that in real-world applications, the true form of \\(f\\) is almost always unknown to us. We never directly observe this function; instead, we must estimate it based on the data we have collected. The entire enterprise of statistical learning revolves around developing methods to estimate \\(f\\) as accurately as possible.\nThe error term, denoted by \\(\\epsilon\\), represents the random component of the relationship between dependent and independent variables. This term captures all the variation in Y that cannot be explained by the \\(X_p\\). The error term is assumed to be independent of X and to have a mean of zero, which means that on average, the errors cancel out and do not systematically bias our predictions in one direction or another. The error term exists for several important reasons.\n\nFirst, there may be variables that influence dependent variable but that we have not measured or included in our analysis.\nSecond, even if we could measure every relevant variable, there might be inherent randomness or unpredictability in the phenomenon we are studying.\nThird, our measurements themselves may contain some degree of imprecision or noise.\n\n\n\n\n\n\n\\(X_1\\) represents the person’s educational credentials, which might be measured as years of schooling completed or as the highest degree obtained.\n\\(X_2\\) represents occupation, which could be coded as occupational prestige scores or as categorical indicators for different types of jobs.\n\\(X_3\\) represents the geographic region where the person lives and works, capturing spatial variation in labor markets and cost of living.\n\\(X_4\\) represents parents’ socioeconomic status, which might be measured through parental income, parental education, or a composite index combining multiple indicators of family background.\n\\(X_5\\) represents race, coded as categorical indicators for different racial or ethnic groups.\n\\(X_6\\) represents gender, typically coded as a binary or categorical variable.\n\\(X_7\\) represents years of work experience, measuring how long the person has been participating in the labor force.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to Statistical Learning</span>"
    ]
  },
  {
    "objectID": "introduction_to_statistical_learning.html#relationship-between-dependent-and-independent-variable",
    "href": "introduction_to_statistical_learning.html#relationship-between-dependent-and-independent-variable",
    "title": "1  Introduction to Statistical Learning",
    "section": "1.2 Relationship between Dependent and Independent Variable",
    "text": "1.2 Relationship between Dependent and Independent Variable\nThe function \\(f\\) is the central object of interest in statistical learning. It represents the systematic relationship between the independent variable and the dependent variable, capturing all the information that the independent variables provide about the dependent variable. When we say that \\(Y = f(X) + \\epsilon\\), we are asserting that the response can be decomposed into two parts: a predictable component \\(f(X)\\) that depends on the values of the predictors, and an unpredictable component \\(\\epsilon\\) that represents random variation. The function \\(f\\) is what connects the world of responses to the world of predictors in a consistent, reproducible manner.\nUnderstanding the nature of \\(f\\) is crucial because it embodies the underlying pattern that governs how changes in the independent variable translate into changes in the dependent variable. If we knew \\(f\\) perfectly, we would understand exactly how each predictor influences the response, how predictors interact with one another, and what response to expect for any given combination of predictor values. However, in virtually all real-world applications, \\(f\\) is unknown. We never observe \\(f\\) directly; we only observe data points consisting of predictor values and corresponding responses. The entire purpose of statistical learning is to use these observed data points to construct an estimate of \\(f\\), which we denote as \\(\\hat{f}\\). The reasons we might want to estimate \\(f\\) fall into two broad categories: prediction and inference. These two goals are conceptually distinct, and they often lead us to prefer different types of statistical learning methods.\nPrediction is concerned with accurately anticipating the value of Y for new observations where we know the predictors X but do not yet know the response of the predictors. In prediction tasks, we treat \\(\\hat{f}\\) as a kind of black box. We do not necessarily care about the internal workings of our estimated function or about which specific predictors matter most. What we care about is whether our estimate \\(\\hat{f}\\) produces accurate predictions when applied to new data. The quality of predictions depends on two sources of error:\n\nThe first is reducible error, which arises because our estimate \\(\\hat{f}\\) is imperfect and does not exactly match the true \\(f\\). We can potentially reduce this error by using better statistical learning methods or by collecting more data.\nThe second is irreducible error, which corresponds to the variance of \\(\\epsilon\\). Even if we had a perfect estimate of \\(f\\), our predictions would still contain some error because Y is inherently influenced by random factors that cannot be predicted from X alone.\n\nInference, by contrast, is concerned with understanding the relationship between the predictors and the outcome. When our goal is inference, we cannot treat \\(\\hat{f}\\) as a black box because we need to know its exact form. We want to answer questions such as which predictors are associated with the response, what is the direction and magnitude of each predictor’s effect, and whether the relationships are linear or more complex. Inference requires that our estimate \\(\\hat{f}\\) be interpretable, meaning that we can examine it and draw substantive conclusions about how the world works.\nIn practice, many research projects involve elements of both prediction and inference. A researcher studying income might want to understand the determinants of earnings while also developing a model that can predict incomes for new individuals. However, there is often tension between these goals because the methods that produce the most accurate predictions are not always the most interpretable, and the most interpretable methods do not always produce the best predictions.\n\n1.2.1 Parametric vs non-parametric methods\nHaving established why we want to estimate \\(f\\), let us now turn to the question of how we estimate \\(f\\). Statistical learning methods for estimating \\(f\\) can be broadly divided into two categories: parametric methods and non-parametric methods. These two approaches differ fundamentally in the assumptions they make about the form of \\(f\\) and in the way they use data to construct an estimate.\nParametric methods proceed in two steps. In the first step, we make an assumption about the functional form of \\(f\\). That is, we specify in advance what kind of mathematical relationship we believe connects the predictors to the outcome. The most common assumption is that \\(f\\) is linear, meaning that we assume the relationship can be written as \\(f(X) = \\beta_0 + \\beta_1X_1 + \\beta_2X_2 + ... + \\beta_pX_p\\). This linear model asserts that the response is a weighted sum of the predictors, where the weights \\(\\beta_1, \\beta_2, ..., \\beta_p\\) are unknown coefficients that quantify the contribution of each predictor, and \\(\\beta_0\\) is an intercept term representing the expected response when all predictors equal zero. By assuming a linear form, we have dramatically simplified the problem. Instead of having to estimate an arbitrary, potentially very complex function \\(f\\), we only need to estimate the intercept and the p coefficients. In the second step of the parametric approach, we use the observed data to fit or train the model. This means finding values of the parameters that make the model match the data as closely as possible. For the linear model, the most common fitting procedure is ordinary least squares, which chooses the parameter values that minimize the sum of squared differences between the observed responses and the responses predicted by the model. Once we have estimated the parameters, our estimate \\(\\hat{f}\\) is fully specified, and we can use it for prediction or inference.\nThe parametric approach has several important advantages. Because we have reduced the problem to estimating a fixed number of parameters, parametric methods are computationally efficient and can work well even with relatively small samples. Furthermore, the resulting models are typically easy to interpret. In a linear model, each coefficient tells us how much the expected responses changes when the corresponding predictor increases by one unit, holding all other predictors constant. This interpretability makes parametric models particularly valuable for inference. However, parametric methods also have a significant limitation. The assumption we make about the form of \\(f\\) may be wrong. If the true relationship between the predictors and the response is nonlinear or involves complex interactions, a linear model will fail to capture these features and will provide a poor approximation to \\(f\\). We can try to address this problem by using more flexible parametric models that include polynomial terms, interaction effects, or other elaborations of the basic linear form. But as we make our parametric model more flexible, we must estimate more parameters, which requires more data and increases the risk of a phenomenon called overfitting. Overfitting occurs when a model fits the training data very well but performs poorly on new data because it has captured random noise rather than genuine patterns. The model essentially memorizes the idiosyncrasies of the particular sample rather than learning the underlying relationship.\nNon-parametric methods take a fundamentally different approach. Instead of assuming a specific functional form for \\(f\\), non-parametric methods seek an estimate that gets close to the data points without imposing strong prior assumptions about the shape of the relationship. The idea is to let the data speak for themselves and to allow \\(\\hat{f}\\) to take whatever form best fits the observed patterns. One example of a non-parametric method is the thin-plate spline, which estimates \\(f\\) as a smooth surface that passes near the observed data points. The analyst does not specify in advance that \\(f\\) should be linear or quadratic or any other particular form. Instead, the method finds a smooth function that fits the data well, subject to some constraint on how wiggly or rough the function is allowed to be. Another example is the k-nearest neighbors method, which predicts the outcome for a new observation by averaging the outcomes of the k training observations that are most similar to it in terms of the predictor values.\nThe main advantage of non-parametric methods is their flexibility. Because they do not assume a particular form for \\(f\\), they can potentially capture a much wider range of relationships, including highly nonlinear patterns and complex interactions that would be missed by a simple parametric model. If the true \\(f\\) has an unusual or complicated shape, a non-parametric method has a better chance of approximating it accurately. However, non-parametric methods also have important disadvantages. Because they do not reduce the problem to estimating a small number of parameters, they typically require much larger samples to produce accurate estimates. The flexibility that allows non-parametric methods to fit complex patterns also makes them prone to overfitting, especially when sample sizes are limited. Furthermore, the estimates produced by non-parametric methods are often difficult to interpret. A non-parametric prediction does not come with coefficients that tell us how each predictor contributes to the outcome. This lack of interpretability makes non-parametric methods less useful for inference, even when they excel at prediction.\nThe choice between parametric and non-parametric methods involves a fundamental trade-off. Parametric methods impose structure on the problem, which makes estimation easier and results more interpretable, but at the cost of potentially misspecifying the true form of \\(f\\). Non-parametric methods avoid this misspecification risk by staying flexible, but they require more data and produce less interpretable results. In practice, the best choice depends on the goals of the analysis, the amount of data available, and how much prior knowledge we have about the likely form of the relationship.\nThis brings us to a closely related issue: the trade-off between prediction accuracy and model interpretability. In statistical learning, there is often an inverse relationship between how flexible a method is and how interpretable its results are. Methods that impose strong restrictions on the form of \\(f\\) tend to be highly interpretable but may not fit complex patterns very well. Methods that are highly flexible can capture intricate relationships but produce results that are difficult for humans to understand.\nAt one end of the spectrum, we have highly restrictive methods like linear regression and its close relatives. Linear regression assumes that \\(f\\) is a linear combination of the predictors, which is a very strong restriction. This restriction means that linear regression can only produce straight lines in one dimension, flat planes in two dimensions, and hyperplanes in higher dimensions. The advantage is that the results are extremely interpretable. Each coefficient has a clear meaning: it tells us the expected change in Y associated with a one-unit increase in the corresponding predictor, holding other predictors constant. We can examine the coefficients and immediately understand which predictors matter, how large their effects are, and in which direction they operate. For inference purposes, this interpretability is invaluable.\nMoving along the spectrum toward greater flexibility, we encounter methods like generalized additive models, which relax the linearity assumption by allowing each predictor to have a potentially nonlinear effect on the response, while still maintaining an additive structure. These models are more flexible than linear regression and can capture curved relationships, but they remain reasonably interpretable because we can plot and examine the estimated effect of each predictor separately. Further along the spectrum, we find decision trees, which partition the predictor space into regions and assign a predicted response to each region. Trees are moderately flexible and can capture interactions and nonlinearities, but they remain somewhat interpretable because we can visualize the tree structure and see which predictors are used to make splits and at what values. These methods can approximate extremely complex functions and often achieve superior predictive accuracy on difficult problems. However, their results are very hard to interpret.\nOne might think that we should always prefer the most flexible method available, reasoning that greater flexibility means better ability to capture the true \\(f\\). Surprisingly, this is not the case. More flexible methods are not always better, even when our sole goal is prediction. The reason is overfitting. A highly flexible method can fit the training data very closely, including the random noise in that particular sample. When we apply the model to new data, the noise patterns will be different, and the overfitted model will perform poorly. In many situations, a simpler, more restrictive model that does not fit the training data as closely will actually generalize better to new observations.\nThis phenomenon is especially important when sample sizes are limited. With a small sample, there is not enough information to reliably estimate a complex, flexible model, and the risk of overfitting is high. In such cases, imposing structure through a parametric model can actually improve predictive performance by preventing the model from chasing noise. As sample sizes grow larger, we can afford to use more flexible methods because there is enough information to distinguish genuine patterns from random variation.\n\n\n1.2.2 Supervised vs unsupervised learning\nTo complete the overview of the foundational concepts in statistical learning, we need to understand additional distinction between supervised and unsupervised learning that help us categorize different types of learning problems.\nSupervised learning refers to situations where for each observation in our dataset, we have both predictor measurements and a corresponding response measurement. The term supervised reflects the idea that the learning process is guided or supervised by the known dependent variables. We observe what actually happened for each case in our training data, and we use this information to learn the relationship between independent variables and dependent variable. All the methods we have discussed so far fall into the supervised learning category when applied to problems where outcomes are observed. The fundamental goal of supervised learning is to build a model that can predict the response for new observations based on their predictor values, or to understand how the predictors relate to the response. In social sciences research, most studies involve supervised learning because we typically have data on both the explanatory variables and the outcome of interest. For example, when we study the relationship between education and income, we observe both variables for the individuals in our sample, which allows us to estimate how education influences earnings.\nUnsupervised learning describes a fundamentally different situation where we observe predictor measurements for each observation but have no corresponding response variable. Without a dependent variable to predict or explain, we cannot fit a regression model or train a classifier. Instead, unsupervised learning seeks to discover patterns, structures, or groupings within the data itself. The most common unsupervised learning task is cluster analysis, which attempts to identify subgroups of observations that are similar to one another. For instance, a researcher might have survey data containing many variables about people’s attitudes, behaviors, and demographic characteristics, but no predefined categorization of people into types. Cluster analysis could reveal that the respondents naturally fall into distinct groups based on their patterns of responses, perhaps identifying clusters that correspond to different lifestyles, political orientations, or consumption patterns. The key feature of unsupervised learning is that there is no correct answer to supervise the learning process. We are not trying to predict a known outcome but rather to uncover hidden structure in the data. This makes unsupervised learning more exploratory and somewhat more subjective than supervised learning, since there is no objective criterion like prediction accuracy to evaluate whether we have found the right structure.\n\nTable 1.1 Summary table of statistical learning methods\n\n\n\n\n\n\n\n\n\nMethod\nUnsupervised / Supervised\nParametric / Non-parametric\nFlexibility\nInterpretability\n\n\n\n\nLinear Regression\nSupervised\nParametric\nLow\nHigh\n\n\nRidge Regression\nSupervised\nParametric\nLow\nHigh\n\n\nLasso\nSupervised\nParametric\nLow\nHigh\n\n\nLogistic Regression\nSupervised\nParametric\nLow\nHigh\n\n\nGeneralized Additive Models\nSupervised\nParametric (additive structure)\nMedium\nMedium-High\n\n\nDecision Trees\nSupervised\nNon-parametric\nMedium\nMedium\n\n\nBagging\nSupervised\nNon-parametric\nHigh\nLow\n\n\nRandom Forests\nSupervised\nNon-parametric\nHigh\nLow\n\n\nBoosting\nSupervised\nNon-parametric\nHigh\nLow\n\n\nLinear Support Vector Machines\nSupervised\nParametric\nLow-Medium\nMedium\n\n\nNonlinear Support Vector Machines\nSupervised\nNon-parametric\nHigh\nLow\n\n\nK-Nearest Neighbors\nSupervised\nNon-parametric\nHigh\nLow\n\n\nNeural Networks\nSupervised\nNon-parametric\nVery High\nVery Low\n\n\nDeep Learning\nSupervised\nNon-parametric\nVery High\nVery Low\n\n\nK-Means Clustering\nUnsupervised\nNon-parametric\nMedium\nMedium\n\n\nHierarchical Clustering\nUnsupervised\nNon-parametric\nMedium\nMedium-High\n\n\nPrincipal Component Analysis\nUnsupervised\nParametric\nLow\nMedium-High\n\n\nFactor Analysis\nUnsupervised\nParametric\nLow\nHigh",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to Statistical Learning</span>"
    ]
  },
  {
    "objectID": "introduction_to_statistical_learning.html#assessing-model-accuracy",
    "href": "introduction_to_statistical_learning.html#assessing-model-accuracy",
    "title": "1  Introduction to Statistical Learning",
    "section": "1.3 Assessing Model Accuracy",
    "text": "1.3 Assessing Model Accuracy\nA fundamental question in statistical learning can be expressed as a: how do we know which method or model is the best one to use for a given dataset? This might seem like a simple question at first, but it is actually one of the most challenging aspects of statistical learning in practice.\nWhen we build a statistical learning model, we need a way to evaluate how well it actually works. In other words, we need to measure how close the model’s predictions are to the real values we observe in the data. This is what we mean by measuring the quality of fit. Without such a measure, we would have no principled way of comparing different models or deciding whether a particular approach is adequate for our research question.\n\n1.3.1 The regression setting\nIn the regression setting, where the response variable is quantitative, the most commonly used measure of fit is the mean squared error (MSE). The mean squared error is calculated by taking each observation in the dataset, computing the difference between the actual observed value and the value that the model predicts, squaring that difference, and then averaging all of these squared differences across every observation. Formally, MSE is expressed as:\n\\(MSE = \\frac{1}{n} \\times \\sum_{i=1}^n(y_i - \\hat{f}(x_i))^2\\)\nThe logic behind this measure is straightforward. If our model’s predictions are very close to the true observed values, the differences will be small, the squared differences will be even smaller, and the average of all those squared differences will be a small number. On the other hand, if the model produces predictions that are far from the actual values for at least some observations, the squared differences will be large, pulling the MSE upward. Squaring the differences serves two purposes: it ensures that positive and negative errors do not cancel each other out, and it penalizes larger errors more heavily than smaller ones.\nTo make this concrete, consider our example of predicting adult income. Suppose the researcher has collected data on a sample of one thousand individuals, recording each person’s educational credentials, occupation, region, parents’ socioeconomic status, race, gender, and years of work experience, along with their actual adult income. The researcher then estimates the function \\(f\\) using some statistical learning method - perhaps a linear regression model - to produce a predicted income \\(\\hat{f}(x_i)\\) for each person in the dataset. For one individual, the model might predict an annual income of 38,000 euros while the person actually earns 42,000 euros, yielding a difference of 4,000 euros. For another individual, the model might predict 55,000 euros while the person earns 53,000 euros, giving a difference of 2,000 euros. The mean squared error takes all of these individual discrepancies, squares each one, and averages them across the entire sample. The resulting number gives us a single summary of how well the model’s predictions match reality.\nThe MSE we just described is computed using the same data that were used to build the model. This is called the training MSE, because it measures how well the model fits the training data - the observations the model has already seen and learned from. At first glance, it might seem perfectly reasonable to use the training MSE to evaluate a model. After all, if a model fits the data well, that should mean it is a good model. However, this reasoning is flawed. In most practical situations, we do not actually care how well the model fits the data it was trained on. What we really care about is how well the model will perform on new data that it has never seen before. This new, unseen data is called test data, and the MSE computed on test data is called the test MSE.\nTo understand why this distinction matters so profoundly, let us return to our income inequality example. Suppose the researcher has built a model using data from a survey conducted in 2018, which includes information on one thousand individuals and their incomes. The model fits these one thousand observations well, producing a low training MSE. But the real purpose of the model is not to predict the incomes of these specific one thousand people whose incomes the researcher already knows. The real purpose is to predict incomes for new individuals - perhaps people surveyed in 2020, or individuals from a different but comparable population - based on their educational credentials, occupation, region, family background, race, gender, and work experience. The question that truly matters is whether the model will produce accurate predictions for these new cases, not whether it accurately reproduces the incomes of the people it was trained on.\nThis is the fundamental insight: the training MSE measures something that is not of primary interest, while the test MSE measures something that is. A model that performs beautifully on its training data might perform poorly on new data, and a model with a somewhat higher training MSE might actually generalize better to unseen observations.\nMany statistical learning methods are designed, either directly or indirectly, to minimize the training MSE. They adjust their estimates and coefficients specifically to fit the training observations as closely as possible. As a result, the training MSE can be driven very low - sometimes all the way to zero - but this does not mean that the model has learned the true underlying patterns in the data. Instead, the model may have started to learn the noise in the training data, the random fluctuations and idiosyncratic features that are specific to that particular sample and will not appear again in new data. In our income example, imagine that the researcher uses a highly flexible model that can adapt to very fine details in the data. This model might learn that in the specific 2018 sample, there was one individual from a particular small region who had low education but unusually high income, perhaps due to an inheritance or a lucky business venture. A very flexible model might adjust its predictions to accommodate this particular case, effectively learning the specific circumstances of this one person rather than the general relationship between education and income. When the model is then applied to new individuals, this kind of overly specific learning will not help and may actually hurt prediction accuracy, because the idiosyncratic patterns of the training data do not generalize to the broader population.\nThe chapter illustrates this problem using the concept of model flexibility. A model’s flexibility refers to how closely it can conform to the patterns in the training data. At one end of the spectrum, a simple linear regression is relatively inflexible - it fits a straight line (or a flat hyperplane in multiple dimensions) through the data. At the other end, highly flexible methods like smoothing splines or very complex nonlinear models can bend and curve to follow almost every individual data point. The key finding, which the chapter demonstrates through several examples, is that as model flexibility increases, the training MSE will always decrease - because a more flexible model can always conform more closely to the training data. However, the test MSE does not simply decrease along with the training MSE. Instead, the test MSE initially decreases as the model becomes flexible enough to capture the real underlying patterns, but at some point it reaches a minimum and then begins to increase again. This produces the characteristic U-shaped curve that appears throughout the book.\nIn the income inequality context, a linear regression model assumes that the relationship between each predictor and income is a straight line. This might miss important nonlinearities - for example, the return to education might increase sharply once a person obtains a university degree, rather than rising smoothly with each additional year of schooling. A somewhat more flexible model could capture this nonlinearity and would likely produce better predictions on new data, yielding a lower test MSE. However, if the researcher keeps increasing flexibility - allowing the model to capture finer and finer details of the training data - at some point the model starts picking up noise rather than signal. It might learn that in this particular sample, people with exactly fourteen years of education and exactly eight years of work experience who live in one specific region have unusually high incomes, when in reality this pattern is just a coincidence in the sample. At this point, the test MSE starts rising again, even as the training MSE continues to fall.\nThe phenomenon, where a model fits the training data too closely and as a result performs poorly on new data, is called overfitting. It occurs when a statistical learning method works too hard to find patterns in the training data and ends up capturing patterns that are caused by random chance rather than by genuine features of the underlying relationship. When overfitting occurs, the training MSE is very low but the test MSE is high, because the spurious patterns the model learned from the training data do not exist in the test data.\nTo understand overfitting in our example, think of it this way. The true relationship between the seven predictors and adult income has a certain level of complexity. Education, occupation, region, family background, race, gender, and work experience all influence income in systematic ways, but those systematic influences operate at a general level - they describe broad patterns that hold across many individuals. A good model captures these broad, stable patterns. An overfit model goes beyond these patterns and starts memorizing the specific incomes of specific individuals in the training sample, including all the random variation that makes each person’s income slightly different from what the general pattern would predict. Since this random variation is specific to the training sample and will not replicate in new data, the overfit model ends up making worse predictions when applied to new observations.\nRegardless of whether overfitting has occurred, the training MSE will almost always be smaller than the test MSE. This is simply because most methods are designed to minimize the training MSE, so they will naturally fit the training data better than any data they have not seen. Overfitting refers specifically to the situation where additional flexibility leads to a worse test MSE - that is, where a less flexible model would actually have produced better predictions on new data.\nIn practice, the researcher can usually compute the training MSE quite easily, since it only requires the data used to fit the model. However, estimating the test MSE is considerably more difficult because test data may not be available. If the researcher studying income inequality has only one dataset, there is no separate pool of unseen observations on which to evaluate the model. One important solution to this problem is cross-validation which provides a way to estimate the test MSE using only the training data by cleverly splitting the data into parts and alternating which part serves as the training set and which serves as the test set. This allows the researcher to approximate how well the model would perform on genuinely new data without actually needing a separate test dataset.\nSummarizing the above, evaluating a model’s quality requires looking beyond how well it fits the data it was trained on. The true measure of a model’s value is its ability to make accurate predictions for observations it has never encountered. This principle applies whether we are predicting any phenomenon in the social sciences. Understanding the distinction between training performance and test performance, and recognizing the danger of overfitting, are essential foundations for the study of statistical learning.\n\n1.3.1.1 The Bias-Variance Trade-Off\nIn the previous section, we established that when we evaluate a statistical learning model, what truly matters is the test MSE - how well the model predicts outcomes for new, previously unseen observations. We also observed that as model flexibility increases, the test MSE tends to follow a characteristic U-shape: it initially decreases, reaches a minimum at some optimal level of flexibility, and then begins to increase again. The bias-variance trade-off is the theoretical explanation for why this U-shape occurs. It is one of the most important concepts in all of statistical learning, and understanding it deeply will help us make better decisions about which models to use and how flexible those models should be.\nExpected test MSE at any given point can always be broken down into the sum of three distinct quantities:\n\nthe variance of the model’s prediction,\nthe squared bias of the model’s prediction, and\nthe variance of the irreducible error.\n\nThis decomposition is expressed formally as:\n\\[\nE(y_0 - \\hat{f}(x_0))^2 = Var(\\hat{f}(x_0)) + [Bias(\\hat{f}(x_0))]^2 + Var(\\epsilon)\n\\]\nThe term on the left side of this equation is the expected test MSE at a particular point \\(x_0\\)​. The word “expected” here has a specific meaning: it refers to the average test MSE we would obtain if we were to repeat the entire process of collecting training data and fitting the model many times over. Each time we collect a new training dataset and fit a model, we would get a slightly different estimate \\(\\hat{f}\\), and therefore a slightly different prediction error at \\(x_0\\)​. The expected test MSE is the average of all these prediction errors across all possible training datasets we might have drawn. This decomposition tells us something profound. It says that the prediction error at any point is not a single monolithic quantity but rather the sum of three fundamentally different sources of error. To build good models, we need to understand each of these three components and how they relate to each other.\n1. Understanding Variance\nThe first component is the variance of \\(\\hat{f}(x_0)\\). Variance, in this context, refers to how much the model’s prediction at the point \\(x_0\\)​ would change if we estimated the model using a different training dataset. Remember that the training data are a sample drawn from a larger population, and if we were to draw a different sample, we would get different data points and therefore a different estimated function \\(\\hat{f}\\)​. If a method has high variance, it means that small changes in the training data lead to large changes in the estimated function and therefore in the predictions the model produces. If a method has low variance, the predictions remain relatively stable regardless of which particular training dataset is used.\nTo understand this in the context of our income inequality example, imagine that the researcher conducts the same study multiple times, each time drawing a new random sample of one thousand individuals from the population. Each sample will contain slightly different people with slightly different combinations of education, occupation, region, family background, race, gender, work experience, and income. Now suppose the researcher fits the same type of model to each of these different samples. If the method has low variance, the predicted income for a person with, say, a university degree, a professional occupation, living in an urban area, from a middle-class family, who is a white male with ten years of work experience would be roughly similar regardless of which particular sample the model was trained on. The predictions would be stable and consistent across different training datasets. However, if the method has high variance, the predicted income for this same hypothetical person could change dramatically depending on which sample happened to be drawn. One sample might produce a prediction of 45,000 euros while another sample, drawn from the same population, might produce a prediction of 52,000 euros, and yet another might yield 39,000 euros. This instability in predictions is what we mean by high variance.\nThe crucial insight is that more flexible methods tend to have higher variance. The reason is intuitive. A highly flexible model can conform closely to the specific patterns in whatever training data it receives. This means it is highly sensitive to the particular observations in the training set. If one influential individual is replaced by another, the flexible model might change its predictions substantially because it was fitting so closely to each data point. In our income example, a very flexible model might learn intricate patterns specific to the particular one thousand people in the sample - perhaps noticing that in this specific dataset, people from a certain small region with a certain combination of education and experience earn unusually high incomes. If a different sample were drawn, this particular pattern would likely not reappear, and the model’s predictions would shift accordingly.\nIn contrast, a simple linear regression model has low variance because it is constrained to fit a straight-line relationship. Changing a few observations in the training data will only shift the line slightly. The predictions are stable because the model’s rigid structure prevents it from responding dramatically to the idiosyncrasies of any particular sample. Whether the researcher uses sample A or sample B, a linear model will produce roughly similar predictions, because it can only capture broad, linear trends that tend to be consistent across samples.\n2. Understanding Bias\nThe second component of the expected test MSE is the squared bias of \\(\\hat{f}(x_0)\\). Bias refers to the error that arises from approximating a real-world phenomenon, which may be very complex, with a simplified model. It measures the difference between the average prediction of our model (averaged over all possible training datasets) and the true value of the function \\(f\\) at the point \\(x_0\\)​. In other words, bias captures how far off our model is, on average, from the truth - not because of random fluctuations in the training data, but because the model itself is structurally incapable of capturing the true relationship.\nReturning to the income inequality example, suppose that the true relationship between the seven predictors and adult income is genuinely complex. Perhaps the return to education is nonlinear, with relatively modest income gains for each additional year of schooling at lower levels but a sharp jump when a person completes a university degree. Perhaps there are important interactions between predictors - for instance, the effect of work experience on income might differ substantially depending on occupation, with experience mattering a great deal in some professions and very little in others. Perhaps the relationship between parental socioeconomic status and adult income is mediated in complex ways by education and region, creating patterns that cannot be captured by a simple additive model.\nIf the researcher uses a simple linear regression to model this complex reality, the model assumes that each predictor has a constant, additive effect on income. It cannot capture the sharp jump at university degree completion, it cannot represent the interaction between experience and occupation, and it cannot model the complex mediating role of family background. No matter how much training data the researcher collects, the linear model will systematically miss these features of the true relationship. This systematic error is bias. The model is biased because its structure is too simple to represent the truth. Even if the researcher could average the predictions across infinitely many training samples, the average prediction of the linear model would still differ from the true \\(f\\) because the model is fundamentally incapable of representing the true relationship.\nMore flexible methods tend to have lower bias because they can adapt to a wider range of possible shapes for \\(f\\). A flexible model that allows for nonlinear effects and interactions would be better able to capture the true complexity of how education, occupation, family background, and other factors jointly determine income. If the model’s structure is rich enough, it can, in principle, approximate the true function \\(f\\) very closely, resulting in low or even negligible bias.\nThe reason this concept is called a trade-off is that bias and variance tend to move in opposite directions as model flexibility changes. Simple, inflexible methods like linear regression have high bias because they impose strong assumptions about the form of \\(f\\) that may not be accurate. But they have low variance because their rigid structure makes them resistant to fluctuations in the training data. Flexible methods, on the other hand, have low bias because they can adapt to complex patterns in the data, but they have high variance because they are sensitive to the specific observations in the training set.\nThe expected test MSE is the sum of variance, squared bias, and the irreducible error. The irreducible error, \\(Var(\\epsilon)\\), is a constant that does not depend on the model at all - it represents the inherent unpredictability in the response that no model, no matter how sophisticated, can eliminate. In our income example, the irreducible error encompasses all the factors that influence income but are not captured by the seven predictors: individual personality traits, chance events, unmeasured forms of discrimination, health shocks, and countless other sources of variation. Since the irreducible error is fixed, the test MSE can only be reduced by managing the other two components: variance and bias.\nAs we increase flexibility, bias decreases. The model becomes better able to capture the true patterns in the data, and the systematic error introduced by an overly simplistic model structure diminishes. At the same time, variance increases. The model becomes more sensitive to the particular training data, and its predictions become less stable across different samples. The test MSE depends on the combined effect of these two opposing forces.\nAt low levels of flexibility, the model has high bias and low variance. The bias dominates the test MSE, and increasing flexibility helps because the reduction in bias is larger than the increase in variance. This is why the test MSE initially decreases as flexibility grows. In our income example, moving from a very rigid model - say, one that predicts the same average income for everyone regardless of their characteristics - to a basic linear regression would substantially reduce bias by allowing the model to capture at least the broad linear relationships between predictors and income. The test MSE would drop considerably because the improvement from lower bias far outweighs the modest increase in variance.\nAt moderate levels of flexibility, the model has found a good balance. It is flexible enough to capture the important patterns in the data but not so flexible that it is chasing noise. This is the point where the test MSE reaches its minimum, representing the best achievable predictive performance for the given set of predictors and the given type of model.\nAt high levels of flexibility, something changes. The bias has already been reduced to a low level, so further increases in flexibility yield only marginal improvements in bias. But variance continues to climb as the model becomes increasingly sensitive to the training data. Now the increase in variance outweighs the decrease in bias, and the test MSE begins to rise. The model is overfitting - it has become so flexible that it is learning noise rather than signal, and its predictions on new data suffer as a result.\nThis is why the test MSE exhibits the U-shape we discussed earlier. The left side of the U corresponds to high-bias, low-variance models that are too simple. The right side corresponds to low-bias, high-variance models that are too complex. The bottom of the U is the sweet spot where bias and variance are optimally balanced.\nLet us trace through this trade-off more concretely using the income inequality study. Suppose the researcher considers a range of models of increasing flexibility. At the simplest extreme, imagine a model that simply predicts the overall average income in the training sample for every individual, regardless of their education, occupation, or any other characteristic. This model has essentially zero variance - it will produce nearly the same prediction no matter which training sample is drawn, because sample means are very stable. But it has enormous bias, because it completely ignores all the systematic relationships between the predictors and income. The test MSE would be very high, driven almost entirely by bias. Next, consider a standard linear regression that includes all seven predictors. This model can capture the average linear effect of education, occupation, region, family background, race, gender, and work experience on income. Compared to the naive average, it has substantially lower bias because it acknowledges that these factors matter and estimates their effects. Its variance is still relatively low because the linear structure constrains the model considerably. The test MSE would be much lower than that of the naive model. Now consider a more flexible model that allows for nonlinear effects - perhaps using polynomial terms or splines to model the relationship between years of education and income, or including interaction terms that allow the effect of work experience to vary by occupation. This model can capture important features of the true relationship that linear regression misses, such as the disproportionate returns to completing a university degree or the different career trajectories across occupations. The bias decreases further. The variance increases somewhat because the model now has more parameters to estimate and is more sensitive to the particular sample. If the true relationship genuinely contains these nonlinearities and interactions, the reduction in bias will outweigh the increase in variance, and the test MSE will decrease. However, if the researcher continues to increase flexibility - adding higher-order polynomial terms, three-way and four-way interactions between predictors, and extremely localized fits - the model begins to adapt to features of the training data that are not part of the true underlying relationship. Perhaps in this specific sample, there happen to be three individuals from a particular region who all have unusually high incomes, and the very flexible model adjusts its predictions for that region upward to accommodate these three people. In a new sample, this pattern would not recur, and the model’s predictions for that region would be systematically too high. The variance is now large, the bias gains from additional flexibility are negligible, and the test MSE starts climbing.\n3. The Irreducible Error as a Floor\nAn important implication of the bias-variance decomposition is that there is a floor below which the test MSE can never fall, no matter how good our model is. This floor is the irreducible error, \\(Var(\\epsilon)\\). In the income inequality example, even if we had a perfect model that captured every systematic relationship between the seven predictors and income, there would still be variation in income that these predictors cannot explain. Two individuals who are identical in terms of education, occupation, region, family background, race, gender, and work experience will still have different incomes, because of all the unmeasured factors that influence earnings. No model built from these seven predictors can predict this residual variation, and so the test MSE can never be reduced below this level.\nThis is an important reminder for social science researchers. The irreducible error is not a failure of the model - it is a reflection of the inherent complexity of social phenomena. Human income is influenced by a vast number of factors, and no finite set of predictors can account for all of them. The goal of statistical learning is not to eliminate all prediction error but to reduce the reducible portion of the error - the part driven by bias and variance - as much as possible.\nThe bias-variance trade-off has profound practical implications for anyone building statistical models in the social sciences. It tells us that the most complex model is not necessarily the best model. A researcher who uses an extremely flexible machine learning method to predict income might achieve a very low training MSE, but if the model has high variance, its predictions on new data could be poor. Conversely, a researcher who sticks with simple linear regression out of tradition might be leaving predictive accuracy on the table if the true relationships are genuinely nonlinear. The trade-off also explains why different datasets may require different levels of model flexibility. If the true relationship between predictors and the response is approximately linear - perhaps because the predictors have been carefully chosen and transformed - then a simple model will have low bias to begin with, and increasing flexibility will mainly add variance without much benefit. If, on the other hand, the true relationship is highly nonlinear and involves complex interactions, a simple model will have high bias, and the researcher needs to use a more flexible approach to capture the important patterns, accepting some increase in variance as the cost of reducing bias.\nIn real-life situations where the true \\(f\\) is unknown - which is essentially always the case in practice - we cannot directly compute the bias, the variance, or even the test MSE. We cannot look at the decomposition and decide exactly where the optimal flexibility lies. Nevertheless, keeping the bias-variance trade-off in mind helps guide our thinking. It reminds us to be skeptical of models that fit the training data too perfectly, to consider whether our model might be too simple or too complex for the phenomenon at hand, and to use techniques like cross-validation to empirically estimate the test MSE and find a good balance between bias and variance.\n\n\n\n1.3.2 The Classification Setting\nUp to this point, our discussion of model accuracy has focused entirely on the regression setting, where the response variable is quantitative. However, many research questions in the social sciences involve response variables that are qualitative rather than quantitative. A qualitative response variable takes on values that represent discrete categories or classes rather than numerical quantities. The classification setting deals with precisely this kind of problem: predicting which category an observation belongs to, rather than predicting a numerical value.\nThe concepts we have already covered - the distinction between training and test performance, the danger of overfitting, and the bias-variance trade-off - all carry over to the classification setting. However, the specific measures we use to evaluate model performance need to be adapted, because it no longer makes sense to talk about squared differences between predicted and actual values when the response is a category rather than a number.\nTo make the classification setting concrete within our sociological example, let us modify the research question slightly. Instead of predicting how much a person earns, suppose the researcher is now interested in predicting whether a person will end up in a state of economic vulnerability or not. The researcher might define economic vulnerability as earning below a certain threshold - say, below 60 percent of the median national income, which is a commonly used measure of relative poverty risk in European social policy research. The response variable Y is now qualitative: for each individual, it takes one of two values, either “economically vulnerable” or “not economically vulnerable”. The predictors remain the same seven variables we have been working with: educational credentials (\\(X_1\\)​), occupation (\\(X_2\\)​), geographic region (\\(X_3\\)​), parents’ socioeconomic status (\\(X_4\\)), race (\\(X_5\\)​), gender (\\(X_6\\)​), and years of work experience (\\(X_7\\)​). The research question is no longer about predicting the exact income a person will earn, but about classifying each individual into one of two categories based on their characteristics. This is a classification problem, and it requires different tools for measuring how well our model performs.\nIn the regression setting, we measured model performance using the mean squared error, which quantifies how far the predicted numerical values are from the actual numerical values. In the classification setting, the natural analogue is the error rate, which simply measures the proportion of observations that are incorrectly classified. The training error rate is computed by applying the model to the training data and counting the fraction of cases where the predicted class does not match the true class. Formally, this is expressed as:\n\\[\n\\frac{1}{n} \\sum_{i=1}^{n} I(y_i \\neq \\hat{y}_i)\n\\]\nIn this formula, \\(\\hat{y}_i\\)​ is the class label that the model predicts for the \\(i\\)-th observation, and \\(I(y_i \\neq \\hat{y}_i)\\) is an indicator function that equals one whenever the prediction is wrong and zero whenever the prediction is correct. By summing these indicators across all observations and dividing by the total number of observations, we get the fraction of misclassifications - the training error rate.\nIn our example, suppose the researcher trains a classification model on data from one thousand individuals. The model predicts, for each person, whether they are economically vulnerable or not. If the model correctly classifies 920 of the 1,000 individuals and misclassifies 80, the training error rate is 80 divided by 1,000, which equals 0.08, or 8 percent. This means the model gets it wrong for 8 percent of the people in the training sample.\nHowever, just as in the regression setting, the training error rate is not what we truly care about. What matters is the test error rate - the proportion of misclassifications when the model is applied to new observations that were not part of the training data. The test error rate is given by:\n\\[\nAve(I(y_0 \\neq \\hat{y}_0))\n\\]\nThis measures the average misclassification rate across test observations. A good classifier is one that achieves the smallest possible test error rate, meaning it correctly classifies the highest proportion of new, unseen individuals.\nIn our context, the researcher wants a model that can accurately predict economic vulnerability for future individuals - people who were not in the original training sample. Perhaps the model will be used to identify individuals at risk of poverty in a new survey wave, or to target social policy interventions toward those most likely to be economically vulnerable. The value of the model lies not in how well it classifies the one thousand people whose outcomes are already known, but in how well it classifies new individuals whose outcomes the researcher does not yet know.\n\n1.3.2.1 The Bayes Classifier\nThe Bayes classifier represents the best possible classification rule - the one that produces the lowest possible test error rate. Understanding the Bayes classifier is important not because we can ever actually use it in practice, but because it provides a benchmark against which all real classification methods can be evaluated.\nThe Bayes classifier works on a deceptively simple principle: for each observation, assign it to the class that is most probable given its predictor values. Formally, for a test observation with predictor vector \\(x_0\\)​, the Bayes classifier assigns the observation to the class \\(j\\) for which the conditional probability \\(Pr(Y = j \\mid X = x_0)\\) is largest.\nTo understand what this means in our example, consider a specific individual - a woman with a university degree, working in a service occupation, living in a rural region, from a lower-middle-class family background, who is white and has five years of work experience. The Bayes classifier asks: given this particular combination of characteristics, what is the probability that this person is economically vulnerable, and what is the probability that she is not? If the probability of being economically vulnerable given her specific profile is 0.25, and the probability of not being economically vulnerable is 0.75, then the Bayes classifier assigns her to the “not economically vulnerable” category, because that is the more probable outcome for someone with her characteristics.\nIn a two-class problem like ours - where the response is either “economically vulnerable” or “not economically vulnerable” - the Bayes classifier reduces to a simple rule: classify the individual as economically vulnerable if the probability of economic vulnerability given their predictor values exceeds 0.5, and classify them as not economically vulnerable otherwise. The boundary in predictor space where the probability of each class is exactly equal — where \\(Pr(Y = vulnerable \\mid X = x_0) = 0.5\\) - is called the Bayes decision boundary. On one side of this boundary, individuals are classified as vulnerable; on the other side, they are classified as not vulnerable.\nThe Bayes classifier produces the lowest possible test error rate, called the Bayes error rate. This rate is given by:\n\\[\n1 - E\\left(\\max_j \\Pr(Y = j \\mid X)\\right)\n\\]\nThe Bayes error rate is greater than zero whenever there is any overlap between the classes in the population - that is, whenever there exist regions of the predictor space where neither class has a probability of one. In our example, this overlap is substantial. Even among people with very similar educational credentials, occupations, and family backgrounds, some will be economically vulnerable and others will not, because of all the unmeasured factors that influence income. No classifier, no matter how sophisticated, can perfectly separate the two groups based on the seven predictors alone. The Bayes error rate represents this fundamental limit on classification accuracy, and it is directly analogous to the irreducible error in the regression setting.\nThe reason the Bayes classifier cannot be used in practice is that it requires perfect knowledge of the conditional probabilities \\(Pr(Y = j \\mid X = x_0)\\) for every possible combination of predictor values. In the real world, we never know these probabilities. We only have sample data from which we can try to estimate these probabilities. The Bayes classifier therefore serves as a theoretical gold standard - an ideal that real methods try to approximate but can never fully achieve.\n\n\n1.3.2.2 K-Nearest Neighbors\nSince the Bayes classifier is unattainable in practice, we need real methods that can approximate it using available data. One such method is the K-nearest neighbors classifier, commonly abbreviated as KNN. The KNN classifier is a conceptually simple approach that directly attempts to estimate the conditional probabilities that the Bayes classifier relies on, and then classifies each observation to the class with the highest estimated probability.\nThe KNN classifier works as follows. Given a positive integer K and a new observation \\(x_0\\)​ that we want to classify, the algorithm first identifies the K training observations that are closest to \\(x_0\\)​ in the predictor space. This set of K nearest neighbors is denoted \\(\\mathcal{N}_0\\)​. The classifier then estimates the conditional probability for each class as the proportion of those K neighbors that belong to that class:\n\\[\n\\Pr(Y = j \\mid X = x_0) = \\frac{1}{K} \\sum_{i \\in \\mathcal{N}_0} I(y_i = j)\n\\]\nFinally, KNN assigns the test observation \\(x_0\\)​ to the class with the largest estimated probability.\nTo see how this works in our income inequality example, suppose the researcher wants to predict whether a new individual - let us call her Person A - is economically vulnerable or not. Person A has a specific set of characteristics: a vocational degree, a clerical occupation, living in a mid-sized city, from a working-class family, who is a white woman with three years of work experience. The KNN classifier, with, say, \\(K = 5\\), would search through the entire training dataset of one thousand individuals and find the five people whose combination of education, occupation, region, family background, race, gender, and work experience is most similar to Person A’s profile. Perhaps among these five nearest neighbors, three are not economically vulnerable and two are economically vulnerable. The estimated probability of being not vulnerable is then 3/5, or 0.6, and the estimated probability of being vulnerable is 2/5, or 0.4. Since 0.6 is greater than 0.5, KNN classifies Person A as not economically vulnerable.\nThe intuition behind KNN is that people with similar characteristics tend to have similar outcomes. If most of the people in the training data who resemble Person A are not economically vulnerable, then it is reasonable to predict that Person A is also not economically vulnerable. This is a form of learning from analogy - the algorithm classifies new cases by looking at the outcomes of the most similar known cases.\nThe value of K - the number of neighbors considered - is a crucial parameter that profoundly affects the behavior of the KNN classifier. The choice of K determines where the classifier falls on the flexibility spectrum and therefore directly influences the bias-variance trade-off. When K is very small, say \\(K = 1\\), the classifier is extremely flexible. It classifies each new observation based on the single most similar training observation. This means the decision boundary - the line separating the region where the model predicts vulnerability from the region where it predicts non-vulnerability - is highly irregular, twisting and turning to accommodate the class label of every individual training observation. With \\(K = 1\\), the training error rate is actually zero, because each training observation is its own nearest neighbor, so the model always correctly classifies every observation in the training set. However, this impressive training performance is misleading. The model has effectively memorized the training data, including all of its noise and idiosyncrasies. When applied to new data, many of these intricate local patterns will not hold up, and the test error rate will be considerably higher than zero.\nIn our example, using \\(K = 1\\) would mean that the classification of a new individual depends entirely on which single person in the training data happens to have the most similar profile. If that nearest neighbor happens to be an unusual case - perhaps someone who is economically vulnerable despite having relatively favorable characteristics, due to some unmeasured factor like a health crisis - the model would make an incorrect prediction. With \\(K = 1\\), the classifier has very low bias because it imposes almost no assumptions about the shape of the true decision boundary, but it has very high variance because the prediction for any new observation can change dramatically depending on which particular training observations happen to be closest.\nWhen K is very large, the classifier becomes much less flexible. With a large K, the model averages over many training observations to make each prediction, which smooths out the local fluctuations and produces a decision boundary that is much more stable. However, if K is too large, the classifier becomes overly rigid. In the extreme case where K equals the total number of training observations, the classifier would simply predict the majority class for every new observation, ignoring the predictor values entirely. This would have very low variance - the prediction would be the same regardless of which training data were used - but very high bias, because it ignores all the information contained in the predictors.\nIn our example, using a very large K, say \\(K = 100\\), would mean that the prediction for each new individual is based on the outcomes of the 100 most similar people in the training data. This large neighborhood includes people who may not actually be very similar to the individual being classified, and the resulting prediction is essentially an average over a broad swath of the population. The decision boundary becomes very smooth, almost linear, and the model loses its ability to capture local patterns in the data - such as the fact that certain specific combinations of low education, unstable occupation, and disadvantaged family background are particularly strong predictors of economic vulnerability.\nFinall, neither extreme or very large K tends to produce good test error rates. With \\(K = 1\\), the classifier overfits by being too responsive to individual data points. With very large K, the classifier underfits by being too insensitive to meaningful patterns. The best test performance is typically achieved at an intermediate value of K that balances the competing demands of bias and variance. In the simulated example presented in the chapter, \\(K = 10\\) produced a test error rate very close to the theoretical minimum set by the Bayes error rate, illustrating that a well-chosen KNN classifier can approximate the unattainable Bayes classifier remarkably well.\nJust as in the regression setting, the test error rate in the classification setting follows the characteristic U-shape as model flexibility varies. For KNN, flexibility is inversely related to K: small values of K correspond to high flexibility, and large values of K correspond to low flexibility. To make the analogy with the regression plots clearer, the chapter plots the error rates as a function of \\(1/K\\), so that moving to the right on the horizontal axis corresponds to increasing flexibility.\nAs \\(1/K\\) increases from near zero toward one - that is, as K decreases from very large values toward one - the training error rate steadily declines, eventually reaching zero at \\(K = 1\\). This mirrors what we saw in the regression setting: more flexible models always fit the training data better. However, the test error rate does not follow the training error rate downward. Instead, it decreases initially as the classifier becomes flexible enough to capture the important patterns separating the two classes, reaches a minimum at some intermediate level of flexibility, and then increases as the classifier becomes so flexible that it starts overfitting to noise in the training data.\nIn our economic vulnerability example, this means that the researcher would find that a moderately flexible KNN classifier - one that considers a reasonable number of neighbors rather than too few or too many - produces the most accurate predictions for new individuals. Using too few neighbors leads to erratic predictions driven by the particular circumstances of a handful of similar individuals in the training data. Using too many neighbors washes out the meaningful differences between people with different risk profiles, producing predictions that are too uniform.\nThe classification setting reinforces the same fundamental lessons we learned in the regression setting. First, training performance is an unreliable guide to how well a model will perform on new data. A classifier that achieves a very low training error rate may be overfitting, memorizing the training data rather than learning generalizable patterns. Second, the bias-variance trade-off applies to classification just as it applies to regression. Simple classifiers have high bias and low variance, flexible classifiers have low bias and high variance, and the best test performance lies somewhere in between. Third, there exists a theoretical limit on how well any classifier can perform - the Bayes error rate - that is determined by the inherent overlap between the classes in the population and by the information content of the available predictors.\nFor research on economic vulnerability, this means that no model built from the seven predictors we have considered can perfectly classify every individual. Some people with seemingly favorable characteristics will nonetheless be economically vulnerable, and some with seemingly unfavorable characteristics will not be. The irreducible error reflects the complexity of social life - the fact that economic outcomes are shaped by a multitude of factors, many of which cannot be captured in any feasible set of measured variables. The goal of the researcher is not to eliminate this irreducible uncertainty but to build a classifier that comes as close as possible to the Bayes ideal, capturing the genuine patterns in the data without being misled by noise.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to Statistical Learning</span>"
    ]
  },
  {
    "objectID": "linear_regression.html",
    "href": "linear_regression.html",
    "title": "2  Linear Regression",
    "section": "",
    "text": "── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.6\n✔ forcats   1.0.1     ✔ stringr   1.6.0\n✔ ggplot2   4.0.1     ✔ tibble    3.3.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.2\n✔ purrr     1.2.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\nRows: 6607 Columns: 20\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (13): Parental_Involvement, Access_to_Resources, Extracurricular_Activit...\ndbl  (7): Hours_Studied, Attendance, Sleep_Hours, Previous_Scores, Tutoring_...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n# A tibble: 6,607 × 20\n   Hours_Studied Attendance Parental_Involvement Access_to_Resources\n           &lt;dbl&gt;      &lt;dbl&gt; &lt;chr&gt;                &lt;chr&gt;              \n 1            23         84 Low                  High               \n 2            19         64 Low                  Medium             \n 3            24         98 Medium               Medium             \n 4            29         89 Low                  Medium             \n 5            19         92 Medium               Medium             \n 6            19         88 Medium               Medium             \n 7            29         84 Medium               Low                \n 8            25         78 Low                  High               \n 9            17         94 Medium               High               \n10            23         98 Medium               Medium             \n# ℹ 6,597 more rows\n# ℹ 16 more variables: Extracurricular_Activities &lt;chr&gt;, Sleep_Hours &lt;dbl&gt;,\n#   Previous_Scores &lt;dbl&gt;, Motivation_Level &lt;chr&gt;, Internet_Access &lt;chr&gt;,\n#   Tutoring_Sessions &lt;dbl&gt;, Family_Income &lt;chr&gt;, Teacher_Quality &lt;chr&gt;,\n#   School_Type &lt;chr&gt;, Peer_Influence &lt;chr&gt;, Physical_Activity &lt;dbl&gt;,\n#   Learning_Disabilities &lt;chr&gt;, Parental_Education_Level &lt;chr&gt;,\n#   Distance_from_Home &lt;chr&gt;, Gender &lt;chr&gt;, Exam_Score &lt;dbl&gt;\n\n\nhttps://www.kaggle.com/datasets/lainguyn123/student-performance-factors",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Linear Regression</span>"
    ]
  }
]